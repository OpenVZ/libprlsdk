#!/usr/bin/env python
# -*- coding: utf-8 -*-
# vim:ts=4:sw=4:expandtab
#
# GenSdk.py
#
# Copyright (c) 1999-2017, Parallels International GmbH
# Copyright (c) 2017-2019 Virtuozzo International GmbH. All rights reserved.
#
# This file is part of Virtuozzo SDK. Virtuozzo SDK is free
# software; you can redistribute it and/or modify it under the
# terms of the GNU Lesser General Public License as published by
# the Free Software Foundation; either version 2.1 of the License,
# or (at your option) any later version.
#
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this library.  If not, see
# <http://www.gnu.org/licenses/>.
#
# Our contact details: Virtuozzo International GmbH, Vordergasse 59, 8200
# Schaffhausen, Switzerland; http://www.virtuozzo.com/.
#

import os, sys, string, re

# Full path of this python file module
__full_file_path__ = os.path.split( os.path.abspath(__file__) )[0]
if __full_file_path__ == '':
    __full_file_path__ = os.path.abspath( os.path.getcwd() )

# Importing BuildUtil Library
sys.path.append( os.path.join( __full_file_path__, '..' ) )
sys.path.append( os.path.join( __full_file_path__, '../Build' ) )

# Importing build utilites - allowing to call TRACE without prefix
import BuildUtil
from BuildUtil import TRACE

ERRORS_FN = 'PrlErrorsValues'
PRIVATE_ERRORS_FN = 'PrlPrivateErrorsValues'
EVENTS_FN = 'PrlEventsValues'
ENUMS_FN  = 'PrlEnums.h'

# Errors flags
PublicErrors = 1
PrivateErrors = 2
AllErrors = PublicErrors | PrivateErrors


SDK_HEADER_PATH = os.path.join(__full_file_path__, 'Include')

HEADER_FILE_HEADER = """/*
 * %(filename)s.h
 *
 * DO NOT EDIT THIS FILE !!!
 * it generated automatically from %(filename)s.txt
 * Please, do not modify header directly - instead use description text file.
 * call Sources/Gen.py or Sources/SDK/GenSdk.py to generate
 *
 * This file is part of Virtuozzo SDK. Virtuozzo SDK is free
 * software; you can redistribute it and/or modify it under the
 * terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation; either version 2.1 of the License,
 * or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library.  If not, see
 * <http://www.gnu.org/licenses/> or write to Free Software Foundation,
 * 51 Franklin Street, Fifth Floor Boston, MA 02110, USA.
 *
 * Our contact details: Virtuozzo International GmbH, Vordergasse 59, 8200
 * Schaffhausen, Switzerland; http://www.virtuozzo.com/.
 */
"""

STRINGIFY_CONSTS_FN = 'PrlStringifyConsts.cpp'
STRINGIFY_CASE_TMPL = '        CASE_VALUE_TO_STRING(%s);'
STRINGIFY_CONSTS_TMPL = """///////////////////////////////////////////////////////////////////////////////
///
/// @file %(filename)s
///
/// DO NOT EDIT THIS FILE !!!
/// it generated automatically from PrlErrorsValues.txt and PrlEventsValues.txt
/// Please, do not modify this file directly - instead use description text file.
/// call Sources/Gen.py or Sources/SDK/GenSdk.py to generate
///
/// @author maximk
///
/// Copyright (c) 1999-2017, Parallels International GmbH
/// Copyright (c) 2017-2019 Virtuozzo International GmbH, All rights reserved.
/// All rights reserved.
///
/// Our contact details: Virtuozzo International GmbH, Vordergasse 59, 8200
/// Schaffhausen, Switzerland; http://www.virtuozzo.com/.
///
///////////////////////////////////////////////////////////////////////////////

#include "PrlStringifyConsts.h"
#include "Libraries/Logging/Logging.h"
#include "Interfaces/ParallelsTypes.h"

#define CASE_VALUE_TO_STRING( r ) \
    case ((unsigned int) r) : return #r ;

#ifdef __cplusplus
extern "C" {
#endif

const char * PrlResultToString(unsigned int value)
{
    switch ( value )
    {
%(errors_case)s
        default:
            WRITE_TRACE(DBG_FATAL, "Unknown PRL_RESULT code %%p", (void*)(ULONG_PTR)value) ;
            break ;
    }
    return "Unknown" ;
}


/**
 * Small utility method to transform event type to string
 */
const char * EventTypeToString(unsigned int value)
{
    switch ( value )
    {
%(events_case)s
        default:
            WRITE_TRACE(DBG_FATAL, "Unknown PRL_EVENT_TYPE value %%p", (void*)(ULONG_PTR)value) ;
            break ;
    }

    return "Unknown" ;
}


/**
 * Small utility method to transform type to string
 */
const char * HandleTypeToString(unsigned int value)
{
    switch ( value )
    {
%(h_types_case)s
        default:
            WRITE_TRACE(DBG_FATAL, "Unknown PRL_HANDLE_TYPE value %%p", (void*)(ULONG_PTR)value) ;
            break ;
    }

    return "Unknown" ;
}

/**
 * Small utility method to transform type to string
 */
const char * VmStateToString(unsigned int value)
{
    switch ( value )
    {
%(vms_types_case)s
        default:
            WRITE_TRACE(DBG_FATAL, "Unknown VIRTUAL_MACHINE_STATE value %%p", (void*)(ULONG_PTR)value) ;
            break ;
    }

    return "Unknown" ;
}

/**
 * Small utility method to transform type to string
 */
const char * LicRestrictionToString(unsigned int value)
{
    switch ( value )
    {
%(restr_types_case)s
        default:
            WRITE_TRACE(DBG_FATAL, "Unknown PRL_LICENSE_RESTRICTION_KEY value %%p", (void*)(ULONG_PTR)value) ;
            break ;
    }

    return "Unknown" ;
}

/**
 * Small utility method to transform type to string
 */
const char * JobOperationCodeToString(unsigned int value)
{
    switch ( value )
    {
%(joc_types_case)s
        default:
            WRITE_TRACE(DBG_FATAL, "Unknown PRL_JOB_OPERATION_CODE value %%p", (void*)(ULONG_PTR)value) ;
            break ;
    }

    return "Unknown" ;
}

#ifdef __cplusplus
}
#endif

"""

def iterate_sequentially(*seqs):
    for s in seqs:
        for i in s:
            yield i

def parse_template_file(file_data, writer, err_flags = AllErrors):

    def parser(data):
        def row(type, text):
            return (text, type)
        header = True
        for line in map(string.rstrip, data.splitlines()):
            if header and not line.startswith('#ifndef'):
                continue
            header = False
            if not line or line[0]!='.':
                yield (line, "")
                continue
            try:
                yield row(*line.split())
            except:
                print "!!!! invalid row: ", line
                raise

    for txt, row_type in parser(file_data):
        if not row_type:
            if err_flags == PrivateErrors:
                txt = txt.replace('__PARALLELS_API_ERRORS_VALUES_H__', \
			    '__PARALLELS_API_PRIVATE_ERRORS_VALUES_H__')
            writer.write_line(txt, True)
        if row_type == '.err' and err_flags & PublicErrors:
            writer.write_err(txt)
        elif row_type == '.suc' and err_flags & PublicErrors:
            writer.write_suc(txt)
        elif row_type == '.perr' and err_flags & PrivateErrors:
            writer.write_err(txt)
        elif row_type == '.psuc' and err_flags & PrivateErrors:
            writer.write_suc(txt)
        elif row_type == '.evt':
            writer.write_evt(txt)
        elif row_type == '.base':
            writer.set_base(int(txt))
        elif row_type == '.align':
            writer.set_align(int(txt))

    return writer


class header_writer(object):

    def __init__(self, dest_fn):
        self.num = None
        self.header = []
        self.err_fmt = '#define %(cur_code)s %(align)s PRL_RESULT_DECLARE_ERROR(%(num)u)'
        self.suc_fmt = '#define %(cur_code)s %(align)s PRL_RESULT_DECLARE_SUCCESS(%(num)u)'
        self.evt_fmt = ' %(cur_code)s %(align)s= %(num)u,'
        self.codes = []
        filename = os.path.splitext(os.path.basename(dest_fn))[0]
        self.file_head = HEADER_FILE_HEADER % locals()
        self.file_head = self.file_head.replace('PrlPrivateErrorsValues.txt', 'PrlErrorsValues.txt')
        self.file_head = self.file_head.splitlines()
        self.dest_filename = dest_fn

    def set_base(self, val):
        self.num = val
        self.write_line('/* +++ BASE VALUE SET TO %u +++ */' % self.num)

    def set_align(self, val):
        self.num = (self.num + 1) / val * val + val
        self.write_line('/* +++ ALIGNED VALUE TO %u +++ */' % self.num)

    def write_line(self, text="", custom_line = False):
        if custom_line:
            dfn = text.split()
            if len(dfn) >= 3 \
               and (dfn[0] == '#define' or (dfn[0] == '#' and dfn[1] == 'define') ) \
               and len(set(dfn) & set(self.codes)) == 0:
                return
        self.header.append(text)

    def write_value(self, fmt, code):
        if not code == '.skip':
            self.codes.append(code)
            self.cur_code = code
            self.align = ""
            self.write_line(fmt % self.__dict__)
        self.num += 1

    def write_err(self, code):
        self.write_value(self.err_fmt, code)

    def write_suc(self, code):
        self.write_value(self.suc_fmt, code)

    def write_evt(self, code):
        self.write_value(self.evt_fmt, code)

    def __is_differ__(self, compare_data):
        return filter(None, iterate_sequentially(self.file_head, self.header)) !=\
            filter(None, map(string.rstrip, compare_data.splitlines()))

    def write_if_differ(self):
        if os.path.exists(self.dest_filename) and \
                not self.__is_differ__(read_file(self.dest_filename)):
            print 'Skip writing %s, it not changed.' % self.dest_filename
            return False
        f = open(self.dest_filename, "w")
        f.write('\n'.join(iterate_sequentially(self.file_head, self.header)))
        f.write('\n')
        return True

    def get_codes_case(self):
        for c in self.codes:
            yield STRINGIFY_CASE_TMPL % c

class events_writer(header_writer):
    pass

class errors_writer(header_writer):

    def __init__(self, dest_fn):
        super(errors_writer, self).__init__(dest_fn)
        self.errors = []

    def write_err(self, code):
        super(errors_writer, self).write_err(code)
        self.errors.append(code)

    def get_errors(self, format_tmpl):
        for c in self.errors:
            yield format_tmpl % c


class enums_writer(object):

    def __init__(self):
        self.enums = []
        self.last_value = 0

    def write_enum(self, name, value):
        try:
            value = int(value, 0)
            self.last_value = value
        except ValueError:
            if value:
                #ignore enum value copies (v1 = v2)
                return
            self.last_value += 1
        self.enums.append((name, self.last_value))

    def get_enums_case(self):
        for n,v in self.enums:
            yield STRINGIFY_CASE_TMPL % n
    get_codes_case = get_enums_case


def parse_enum_file(file_data, writer, prefix):

    enum_match = re.compile("\s*(%s[A-Z_0-9]+)\s*(=\s*(-?0?[Xx]?[0-9]+|[A-Za-z_]+),?|,?)" % prefix)

    for line in file_data.splitlines():
        m = enum_match.match(line)
        if not m:
            continue
        writer.write_enum(m.group(1), m.group(3))

    return writer


def read_file(file_name, path=''):
    file_name = path and os.path.join(path, file_name) or file_name
    return open(file_name).read()


def write_if_differ(new_data, dest_filename):
    if os.path.exists(dest_filename) and \
            new_data == read_file(dest_filename):
        print 'Skip writing %s, it not changed.' % dest_filename
        return False
    open(dest_filename, "w").write(new_data)
    return True

def write_source_file(errors, events, h_types, vms_types, restr_types, joc_types, file_name):
    values = {
        'filename': os.path.basename(file_name),
        'errors_case': '\n'.join(errors.get_codes_case()),
        'events_case': '\n'.join(events.get_codes_case()),
        'h_types_case': '\n'.join(h_types.get_codes_case()),
        'vms_types_case': '\n'.join(vms_types.get_codes_case()),
        'restr_types_case': '\n'.join(restr_types.get_codes_case()),
        'joc_types_case': '\n'.join(joc_types.get_codes_case())
    }
    return write_if_differ(STRINGIFY_CONSTS_TMPL % values, file_name)

def get_errors(err_flags = AllErrors):
    return parse_template_file(
        read_file( ERRORS_FN  + '.txt', SDK_HEADER_PATH),
        errors_writer(os.path.join(SDK_HEADER_PATH,
                                   (PRIVATE_ERRORS_FN, ERRORS_FN)[err_flags & PublicErrors] + '.h')),
                               err_flags)

def get_events():
    return parse_template_file(
        read_file(EVENTS_FN + '.txt', SDK_HEADER_PATH),
        events_writer(os.path.join(SDK_HEADER_PATH, EVENTS_FN + '.h')))

def gen_string_consts():
    LIBSTD_PATH = os.path.join(__full_file_path__, '../Libraries/PrlCommonUtilsBase')
    h_types = parse_enum_file(
        read_file(ENUMS_FN, SDK_HEADER_PATH),
        enums_writer(),
        'PHT_')
    vms_types = parse_enum_file(
        read_file(ENUMS_FN, SDK_HEADER_PATH),
        enums_writer(),
        'VMS_')
    restr_types = parse_enum_file(
        read_file(ENUMS_FN, SDK_HEADER_PATH),
        enums_writer(),
        'PLRK_')
    joc_types = parse_enum_file(
        read_file(ENUMS_FN, SDK_HEADER_PATH),
        enums_writer(),
        'PJOC_')

    write_source_file(
        get_errors(),
        get_events(),
        h_types,
        vms_types,
        restr_types,
        joc_types,
        os.path.join(LIBSTD_PATH, STRINGIFY_CONSTS_FN))

def gen_header():
    get_errors(PublicErrors).write_if_differ()
    get_errors(PrivateErrors).write_if_differ()
    get_events().write_if_differ()

def main():
    try:
        if len(sys.argv) < 2:
            print 'Usage: GenSdk.py [header] [string-consts] [all]'
            print '   header        - generates PrlErrorsValues.h and PrlEventsValues.h'
            print '   string-consts - generates PrlStringifyConsts.cpp'
            print '   all           - generate all ( headers + strings-consts )'
            return 2

        for arg in sys.argv[1:]:
            if arg == 'string-consts':
                gen_string_consts()
            elif arg == 'header':
                gen_header()
            elif arg == 'all':
                gen_header()
                gen_string_consts()
            else:
                print 'ERROR: unknown argument "%s"' % arg
                return 2
    except Exception, e:
        print e
        return 1
    return 0

if ( __name__ == '__main__' ):
    sys.exit( main() )
