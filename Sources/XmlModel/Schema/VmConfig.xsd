<?xml version="1.0" encoding="UTF-8"?>
<!-- edited with XML Spy v4.3 U (http://www.xmlspy.com) by Max Y. (Parallels) -->
<!-- edited with XMLSpy v2007 sp2 (http://www.altova.com) by artemr (EMBRACE) -->
<!-- edited with XMLSPY v5 rel. 4 U (http://www.xmlspy.com) by rth77 (rth77) -->
<!--W3C Schema generated by XMLSPY v5 rel. 4 U (http://www.xmlspy.com)-->
<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema" elementFormDefault="qualified">
	<xs:element name="AccelerationLevel" type="xs:integer" default="PVA_ACCELERATION_HIGH">
		<xs:annotation>
			<xs:documentation>type=PRL_VM_ACCELERATION_LEVEL;</xs:documentation>
		</xs:annotation>
	</xs:element>
	<xs:complexType name="ActionsType">
		<xs:sequence>
			<xs:element ref="OnAppQuit"/>
			<xs:element ref="OnStop"/>
			<xs:element ref="OnPause"/>
		</xs:sequence>
	</xs:complexType>
	<xs:element name="AdapterName" type="xs:string">
		<xs:annotation>
			<xs:documentation>method=BoundAdapterName;</xs:documentation>
		</xs:annotation>
	</xs:element>
	<xs:element name="AdapterNumber" type="xs:int">
		<xs:annotation>
			<xs:documentation>method=BoundAdapterIndex;</xs:documentation>
		</xs:annotation>
	</xs:element>
	<xs:element name="AutoConnect" type="xs:boolean"/>
	<xs:element name="AutoStart" type="xs:boolean"/>
	<xs:element name="BackgroundPriority" type="xs:integer" default="PVR_PRIORITY_NORMAL">
		<xs:annotation>
			<xs:documentation>type=PRL_VM_PRIORITY;</xs:documentation>
		</xs:annotation>
	</xs:element>
	<xs:complexType name="BootDeviceType">
		<xs:sequence>
			<xs:element ref="Type"/>
			<xs:element ref="BootingNumber"/>
			<xs:element ref="InUse"/>
		</xs:sequence>
		<xs:attribute name="index" use="required">
			<xs:simpleType>
				<xs:restriction base="xs:NMTOKEN">
					<xs:enumeration value="1"/>
					<xs:enumeration value="2"/>
				</xs:restriction>
			</xs:simpleType>
		</xs:attribute>
	</xs:complexType>
	<xs:element name="BootingNumber" type="xs:integer"/>
	<xs:complexType name="BootingOrderType"/>
	<xs:complexType name="CdRomType">
		<xs:annotation>
			<xs:documentation>class=CVmOpticalDisk;base_class=CVmMassStorageDevice;object_id=on;</xs:documentation>
			<xs:documentation source="Comparision operator">header_fragment:
    virtual bool operator==( const CVmOpticalDisk&amp; cVmOpticalDisk );
</xs:documentation>
			<xs:documentation source="Comparision operator_impl">unit_fragment:
bool CVmOpticalDisk::operator==( const CVmOpticalDisk&amp; cVmOpticalDisk )
{
    return CVmMassStorageDevice::operator ==(cVmOpticalDisk);
}
</xs:documentation>
			<xs:documentation source="getDeviceType">header_fragment:
    virtual PRL_DEVICE_TYPE getDeviceType() const { return PDE_OPTICAL_DISK; }
</xs:documentation>
			<xs:documentation source="getEmulatedType">header_fragment:
    PVE::CdromEmulatedType getEmulatedType() const { return (PVE::CdromEmulatedType )CVmDevice::getEmulatedType(); }
</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="Index" type="xs:integer">
				<xs:annotation>
					<xs:documentation>attribute=index;method_base_class=CVmDevice;</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Enabled" type="xs:integer">
				<xs:annotation>
					<xs:documentation>method_base_class=CVmDevice;type=PVE::DeviceEnabledState;</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Connected" type="xs:integer">
				<xs:annotation>
					<xs:documentation>method_base_class=CVmDevice;type=PVE::DeviceConnectedState;</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="EmulatedType" type="xs:integer">
				<xs:annotation>
					<xs:documentation>method_base_class=CVmDevice;default=PVE::RealCdRom;</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="SystemName" type="xs:string">
				<xs:annotation>
					<xs:documentation>method_base_class=CVmDevice;</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="UserFriendlyName" type="xs:string">
				<xs:annotation>
					<xs:documentation>method_base_class=CVmDevice;</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Remote" type="xs:boolean">
				<xs:annotation>
					<xs:documentation>method_base_class=CVmDevice;</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="InterfaceType" type="xs:integer">
				<xs:annotation>
					<xs:documentation>method_base_class=CVmClusteredDevice;type=PRL_MASS_STORAGE_INTERFACE_TYPE;</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="StackIndex" type="xs:integer">
				<xs:annotation>
					<xs:documentation>method_base_class=CVmClusteredDevice;</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Passthrough" type="xs:integer">
				<xs:annotation>
					<xs:documentation>method_base_class=CVmClusteredDevice;type=PVE::DevicePassthroughMode;</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="SubType" type="xs:integer" minOccurs="0">
				<xs:annotation>
					<xs:documentation>method_base_class=CVmClusteredDevice;type=PRL_CLUSTERED_DEVICE_SUBTYPE;</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="DeviceDescription" type="xs:string" minOccurs="0">
				<xs:annotation>
					<xs:documentation>method=Description;method_base_class=CVmDevice;</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
	</xs:complexType>
	<xs:element name="ChangeDateTime" type="xs:dateTime" fixed="read_only_for_merge">
		<xs:annotation>
			<xs:documentation>method=LastModifDate;default=QDateTime::fromString( XML_DEFAULT_DATE_TIME, XML_DATETIME_FORMAT );</xs:documentation>
			<xs:documentation source="Tag condition">condition:m_dtChangeDateTime.isValid() &amp;&amp; (m_dtChangeDateTime != QDateTime::fromString( XML_DEFAULT_DATE_TIME, XML_DATETIME_FORMAT ) )</xs:documentation>
		</xs:annotation>
	</xs:element>
	<xs:element name="ChangedBy" type="xs:string" fixed="read_only_for_merge">
		<xs:annotation>
			<xs:documentation>method=ModifierName;</xs:documentation>
			<xs:documentation source="Tag condition">condition:!m_qsChangedBy.isEmpty() &amp;&amp; !m_qsChangedBy.isNull()</xs:documentation>
		</xs:annotation>
	</xs:element>
	<xs:element name="CloseAppOnShutdown" type="xs:boolean"/>
	<xs:complexType name="CoherenceType">
		<xs:annotation>
			<xs:documentation>class=CVmCoherence;</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element ref="ShowTaskBar"/>
			<xs:element name="ShowTaskBarInCoherence" type="xs:boolean" minOccurs="0"/>
			<xs:element ref="RelocateTaskBar"/>
			<xs:element ref="ExcludeDock"/>
			<xs:element ref="MultiDisplay"/>
			<xs:element name="GroupAllWindows" type="xs:boolean">
				<xs:annotation>
					<xs:documentation/>
					<xs:documentation source="patch on">patch:</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="DisableDropShadow" type="xs:boolean"/>
			<xs:element name="DoNotMinimizeToDock" type="xs:boolean">
				<xs:annotation>
					<xs:documentation/>
					<xs:documentation source="patch on">patch:</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="BringToFront" type="xs:boolean">
				<xs:annotation>
					<xs:documentation/>
					<xs:documentation source="patch on">patch:</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="AppInDock" type="xs:integer" minOccurs="0"/>
			<xs:element name="ShowWinSystrayInMacMenu" type="xs:boolean" default="true" minOccurs="0"/>
			<xs:element name="UseBorders" type="xs:boolean" default="false" minOccurs="0"/>
			<xs:element name="UseSeamlessMode" type="xs:boolean" default="true" minOccurs="0"/>
			<xs:element name="SwitchToFullscreenOnDemand" type="xs:boolean" default="true" minOccurs="0"/>
			<xs:element name="PauseIdleVM" type="xs:boolean" minOccurs="0"/>
			<xs:element name="DisableAero" type="xs:boolean" minOccurs="0"/>
			<xs:element name="CoherenceButtonVisibility" type="xs:boolean" default="true" minOccurs="0"/>
			<xs:element name="AlwaysOnTop" type="xs:boolean" default="false" minOccurs="0">
				<xs:annotation>
					<xs:documentation/>
					<xs:documentation source="patch on">patch:</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="WindowAnimation" type="xs:integer" default="1" minOccurs="0"/>
		</xs:sequence>
	</xs:complexType>
	<xs:complexType name="CtResourceType">
		<xs:annotation>
			<xs:documentation>class=CCtResource;</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="ResourceId" type="xs:integer">
				<xs:annotation>
					<xs:documentation>type=PRL_CT_RESOURCE;</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Barrier" type="xs:unsignedLong"/>
			<xs:element name="Limit" type="xs:unsignedLong"/>
		</xs:sequence>
	</xs:complexType>
	<xs:element name="Connected" type="xs:boolean">
		<xs:annotation>
			<xs:documentation>type=PVE::DeviceConnectedState;</xs:documentation>
		</xs:annotation>
	</xs:element>
	<xs:element name="CpuQuantity" type="xs:integer"/>
	<xs:element name="DiskCachePolicy" type="xs:integer" default="PVE::DiskCacheWritebackEnabled">
		<xs:annotation>
			<xs:documentation>type=PVE::DiskCacheWritebackOption;</xs:documentation>
		</xs:annotation>
	</xs:element>
	<xs:element name="EnableVTxSupport" type="xs:integer" default="PVE::VTxSupportEnabled">
		<xs:annotation>
			<xs:documentation>type=PVE::VTxSupportFlag;</xs:documentation>
			<xs:documentation source="patch on">patch:</xs:documentation>
		</xs:annotation>
	</xs:element>
	<xs:element name="Enabled" type="xs:boolean"/>
	<xs:element name="ExcludeDock" type="xs:boolean" default="XML_DEFAULT_CHRN_EXCLUDEDOCK">
		<xs:annotation>
			<xs:documentation/>
			<xs:documentation source="patch on">patch:</xs:documentation>
		</xs:annotation>
	</xs:element>
	<xs:complexType name="FddType">
		<xs:annotation>
			<xs:documentation>class=CVmFloppyDisk;base_class=CVmStorageDevice;object_id=on;</xs:documentation>
			<xs:documentation source="Comparision operator">header_fragment:
    virtual bool operator==( const CVmFloppyDisk&amp; cVmFloppyDisk );
</xs:documentation>
			<xs:documentation source="Comparision operator_impl">unit_fragment:
bool CVmFloppyDisk::operator==( const CVmFloppyDisk&amp; cVmFloppyDisk )
{
    return CVmStorageDevice::operator ==(cVmFloppyDisk);
}
</xs:documentation>
			<xs:documentation source="getDeviceType">header_fragment:
    virtual PRL_DEVICE_TYPE getDeviceType() const { return PDE_FLOPPY_DISK; }
</xs:documentation>
			<xs:documentation source="getEmulatedType">header_fragment:
    PVE::FloppyEmulatedType getEmulatedType() const { return (PVE::FloppyEmulatedType )CVmDevice::getEmulatedType(); }
</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="Index" type="xs:integer">
				<xs:annotation>
					<xs:documentation>attribute=index;method_base_class=CVmDevice;</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Enabled" type="xs:integer">
				<xs:annotation>
					<xs:documentation>method_base_class=CVmDevice;type=PVE::DeviceEnabledState;</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Connected" type="xs:integer">
				<xs:annotation>
					<xs:documentation>method_base_class=CVmDevice;type=PVE::DeviceConnectedState;</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="EmulatedType" type="xs:integer">
				<xs:annotation>
					<xs:documentation>method_base_class=CVmDevice;default=PVE::RealFloppyDisk;</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="SystemName" type="xs:string">
				<xs:annotation>
					<xs:documentation>method_base_class=CVmDevice;</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="UserFriendlyName" type="xs:string">
				<xs:annotation>
					<xs:documentation>method_base_class=CVmDevice;</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Remote" type="xs:boolean">
				<xs:annotation>
					<xs:documentation>method_base_class=CVmDevice;</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="DeviceDescription" type="xs:string" minOccurs="0">
				<xs:annotation>
					<xs:documentation>method=Description;method_base_class=CVmDevice;</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
	</xs:complexType>
	<xs:complexType name="EFIVariableType">
		<xs:sequence>
			<xs:element name="Name" type="xs:string"/>
			<xs:element name="Value" type="xs:string"/>
		</xs:sequence>
	</xs:complexType>
	<xs:element name="FolderDescription" type="xs:string">
		<xs:annotation>
			<xs:documentation>method=Description;</xs:documentation>
		</xs:annotation>
	</xs:element>
	<xs:element name="ForegroundPriority" type="xs:integer" default="PVR_PRIORITY_NORMAL">
		<xs:annotation>
			<xs:documentation>type=PRL_VM_PRIORITY;</xs:documentation>
		</xs:annotation>
	</xs:element>
	<xs:complexType name="FullScreenType">
		<xs:annotation>
			<xs:documentation>class=CVmFullScreen;</xs:documentation>
			<xs:documentation source="get \ set per corner actions">header_fragment:
	PRL_CORNER_ACTIONS getCornerAction(PRL_WINDOW_CORNERS nCorner);
	void setCornerAction(PRL_WINDOW_CORNERS nCorner, PRL_CORNER_ACTIONS nAction);</xs:documentation>
			<xs:documentation source="get \ set per corner actions impl.">unit_fragment:
PRL_CORNER_ACTIONS CVmFullScreen::getCornerAction(PRL_WINDOW_CORNERS nCorner)
{
	if ( nCorner &lt; m_lstCornerAction.size() )
		return m_lstCornerAction[nCorner];
	return PCA_NO_ACTION;
}

void CVmFullScreen::setCornerAction(PRL_WINDOW_CORNERS nCorner, PRL_CORNER_ACTIONS nAction)
{
	if ( m_lstCornerAction.isEmpty() )
		m_lstCornerAction &lt;&lt; PCA_NO_ACTION
				  &lt;&lt; PCA_NO_ACTION
				  &lt;&lt; PCA_NO_ACTION
				  &lt;&lt; PCA_NO_ACTION;

	if ( nCorner &lt; m_lstCornerAction.size() )
	{
		QList&lt;PRL_CORNER_ACTIONS&gt; lstCornerAction = m_lstCornerAction;
		lstCornerAction[nCorner] = nAction;
		setCornerActions(lstCornerAction);
	}
}
</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="UseAllDisplays" type="xs:boolean"/>
			<xs:element name="UseActiveCorners" type="xs:boolean" default="false" minOccurs="0"/>
			<xs:element name="UseNativeFullScreen" type="xs:boolean" default="true" minOccurs="0"/>
			<xs:element name="CornerAction" type="xs:integer" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>method=CornerActions;type=PRL_CORNER_ACTIONS;</xs:documentation>
					<xs:documentation source="patch on">patch:</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="ScaleViewMode" type="xs:integer" default="PSVM_AUTO" minOccurs="0">
				<xs:annotation>
					<xs:documentation>type=PRL_SCALE_VIEW_MODE;</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="EnableGammaControl" type="xs:boolean" default="true" minOccurs="0"/>
		</xs:sequence>
	</xs:complexType>
	<xs:complexType name="GeneralType">
		<xs:annotation>
			<xs:documentation>class=CVmCommonOptions;</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element ref="OsType"/>
			<xs:element name="OsNumber" type="xs:integer">
				<xs:annotation>
					<xs:documentation>method=OsVersion;</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="PrevOsNumber" type="xs:integer" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>method=PrevOsVersions;</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Icon" type="xs:string" minOccurs="0">
				<xs:annotation>
					<xs:documentation>condition:!( m_qsIcon.isNull() || m_qsIcon.isEmpty() )</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="VmDescription" type="xs:string" minOccurs="0"/>
			<xs:element name="IsTemplate" type="xs:boolean">
				<xs:annotation>
					<xs:documentation>method=Template;</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="CustomProperty" type="xs:string" minOccurs="0"/>
			<xs:element name="SwapDir" type="xs:string" minOccurs="0"/>
			<xs:element name="VmColor" type="xs:integer" default="0" minOccurs="0"/>
			<xs:element name="ConfigSampleName" type="xs:string" minOccurs="0">
				<xs:annotation>
					<xs:documentation>no_save=on</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Profile">
				<xs:annotation>
					<xs:documentation>single_fixed=on;class=CVmProfile;</xs:documentation>
				</xs:annotation>
				<xs:complexType>
					<xs:sequence>
						<xs:element name="Type" type="xs:integer" default="VMP_PRODUCTIVITY">
							<xs:annotation>
								<xs:documentation>type=PRL_VIRTUAL_MACHINE_PROFILE;</xs:documentation>
							</xs:annotation>
						</xs:element>
						<xs:element name="Custom" type="xs:boolean" minOccurs="0">
							<xs:annotation>
								<xs:documentation/>
								<xs:documentation source="patch on">patch:</xs:documentation>
							</xs:annotation>
						</xs:element>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<xs:element name="AssetId" type="xs:string" minOccurs="0"/>
		</xs:sequence>
	</xs:complexType>
	<xs:complexType name="GlobalNetworkType">
		<xs:annotation>
			<xs:documentation>class=CVmGlobalNetwork;</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="HostName" type="xs:string"/>
			<xs:element name="DefaultGateway" type="xs:string" minOccurs="0"/>
			<xs:element name="DefaultGatewayIPv6" type="xs:string" minOccurs="0"/>
			<xs:element name="OfflineManagementEnabled" type="xs:boolean" default="false" minOccurs="0"/>
			<xs:element name="AutoApplyIpOnly" type="xs:boolean" minOccurs="0"/>
			<xs:element name="DnsIPAddress" type="xs:string" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>method=DnsIPAddresses;</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="SearchDomain" type="xs:string" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>method=SearchDomains;</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="OfflineService" type="xs:string" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>method=OfflineServices;</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="NetworkRates">
				<xs:annotation>
					<xs:documentation>single_fixed=on;class=CVmNetworkRates;</xs:documentation>
				</xs:annotation>
				<xs:complexType>
					<xs:sequence>
						<xs:element name="RateBound" type="xs:boolean" default="false" minOccurs="0"/>
						<xs:element name="NetworkRate" minOccurs="0" maxOccurs="unbounded">
							<xs:annotation>
								<xs:documentation>list=NetworkRates;class=CVmNetworkRate;</xs:documentation>
							</xs:annotation>
							<xs:complexType>
								<xs:sequence>
									<xs:element name="ClassId" type="xs:integer" minOccurs="0"/>
									<xs:element name="Rate" type="xs:integer" minOccurs="0"/>
								</xs:sequence>
							</xs:complexType>
						</xs:element>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
		</xs:sequence>
	</xs:complexType>
	<xs:complexType name="HardwareType">
		<xs:annotation>
			<xs:documentation>class=CVmHardware;</xs:documentation>
			<xs:documentation>include="CVmMassStorageDevice.h";</xs:documentation>
			<xs:documentation source="addIdeDevice">header_fragment:
    QList&lt;CVmMassStorageDevice* &gt;    m_lstIdeDevices;

    void addIdeDevice(CVmMassStorageDevice* device);

private:

    bool m_bAddingTypedDevice;
    bool m_bAddingOpticalDisk;
    bool m_bAddingHardDisk;

public:
</xs:documentation>
			<xs:documentation source="addIdeDevice_impl">unit_fragment:
void CVmHardware::addIdeDevice(CVmMassStorageDevice* device)
{
	m_bAddingTypedDevice = true;

	m_lstIdeDevices.append( device );
	
	if( device-&gt;getDeviceType() == PDE_OPTICAL_DISK )
	{
		if( !m_bAddingOpticalDisk )
			addOpticalDisk( (CVmOpticalDisk*)device );
	}
	else
	if( device-&gt;getDeviceType() == PDE_HARD_DISK )
	{
		if( !m_bAddingHardDisk )
			addHardDisk( (CVmHardDisk*)device );
	}

	m_bAddingTypedDevice = false;
}
</xs:documentation>
			<xs:documentation source="Add device">header_fragment:
    void addGenericDevice(CVmGenericDevice* device);
    void addGenericPciDevice(CVmGenericPciDevice* device);
    void addGenericScsiDevice(CVmGenericScsiDevice* device);
    void addFloppyDisk(CVmFloppyDisk* device);
    void addOpticalDisk(CVmOpticalDisk* device);
    void addHardDisk(CVmHardDisk* device);
    void addSerialPort(CVmSerialPort* device);
    void addParallelPort(CVmParallelPort* device);
    void addNetworkAdapter(CVmGenericNetworkAdapter* device);
    void addSoundDevice(CVmSoundDevice* device);
    void addUsbDevice(CVmUsbDevice* device);
</xs:documentation>
			<xs:documentation source="Add device_impl">unit_fragment:
void CVmHardware::addGenericDevice(CVmGenericDevice* device)
{
    m_lstGenericDevices.append( device );
}

void CVmHardware::addGenericPciDevice(CVmGenericPciDevice* device)
{
     m_lstGenericPciDevices.append( device );
}

void CVmHardware::addGenericScsiDevice(CVmGenericScsiDevice* device)
{
     m_lstGenericScsiDevices.append( device );
}

void CVmHardware::addFloppyDisk(CVmFloppyDisk* device)
{
     m_lstFloppyDisks.append( device );
}

void CVmHardware::addOpticalDisk(CVmOpticalDisk* device)
{
    m_bAddingOpticalDisk = true;
	
    m_lstOpticalDisks.append( device );
	
    if( device-&gt;getInterfaceType() == PMS_IDE_DEVICE )
    {
         if( !m_bAddingTypedDevice )
            addIdeDevice( (CVmMassStorageDevice*)device );
    }
	
    m_bAddingOpticalDisk = false;
}

void CVmHardware::addHardDisk(CVmHardDisk* device)
{
    m_bAddingHardDisk = true;
	
    m_lstHardDisks.append( device );
	
    if( device-&gt;getInterfaceType() == PMS_IDE_DEVICE )
    {
        if(!m_bAddingTypedDevice )
            addIdeDevice( (CVmMassStorageDevice*)device );
    }
	
     m_bAddingHardDisk = false;
}

void CVmHardware::addSerialPort(CVmSerialPort* device)
{
     m_lstSerialPorts.append( device );
}

void CVmHardware::addParallelPort(CVmParallelPort* device)
{
     m_lstParallelPorts.append( device );
}

void CVmHardware::addNetworkAdapter(CVmGenericNetworkAdapter* device)
{
     m_lstNetworkAdapters.append( device );
}

void CVmHardware::addSoundDevice(CVmSoundDevice* device)
{
     m_lstSoundDevices.append( device );
}

void CVmHardware::addUsbDevice(CVmUsbDevice* device)
{
     m_lstUsbDevices.append( device );
}
</xs:documentation>
			<xs:documentation source="Absolute/relative path">header_fragment:
private:

// set images path to relative
template&lt;class T&gt;
void SetDevicesListPathsToRelative(const QString &amp; strVmDir,QList&lt;T*&gt; listToProcess, bool bShadowVm = false)
{
	for( int iDevListIndex = 0; iDevListIndex &lt; listToProcess.count(); iDevListIndex++ )
	{
		listToProcess[iDevListIndex]-&gt;setRelativeSystemName(strVmDir, bShadowVm);
	}
}

// revert devices images path to absolute
template&lt;class T&gt;
void RevertDevicesListPathsToAbsolute(const QString &amp; strVmDir,QList&lt;T*&gt; listToProcess)
{
	for( int iDevListIndex = 0; iDevListIndex &lt; listToProcess.count(); iDevListIndex++ )
	{
		listToProcess[iDevListIndex]-&gt;RevertToInitialSystemName(strVmDir);
	}
}

public:
    // set all device images path to relative
    void SetDevicesPathToRelative(const QString &amp; strVmDir, bool bShadowVm = false);
    // revert all device images path to absolute
    void RevertDevicesPathToAbsolute(const QString &amp; strVmDir);
</xs:documentation>
			<xs:documentation source="Absolute/relative path_impl">unit_fragment:
// set all device images path to relative
void CVmHardware::SetDevicesPathToRelative(const QString &amp; strVmDir, bool bShadowVm)
{
	SetDevicesListPathsToRelative(strVmDir,m_lstFloppyDisks, bShadowVm);
	SetDevicesListPathsToRelative(strVmDir,m_lstOpticalDisks, bShadowVm);
	SetDevicesListPathsToRelative(strVmDir,m_lstHardDisks, bShadowVm);
	SetDevicesListPathsToRelative(strVmDir,m_lstSerialPorts, bShadowVm);
	SetDevicesListPathsToRelative(strVmDir,m_lstParallelPorts, bShadowVm);
}

// revert all device images path to absolute
void CVmHardware::RevertDevicesPathToAbsolute(const QString &amp; strVmDir)
{
	RevertDevicesListPathsToAbsolute(strVmDir,m_lstFloppyDisks);
	RevertDevicesListPathsToAbsolute(strVmDir,m_lstOpticalDisks);
	RevertDevicesListPathsToAbsolute(strVmDir,m_lstHardDisks);
	RevertDevicesListPathsToAbsolute(strVmDir,m_lstSerialPorts);
	RevertDevicesListPathsToAbsolute(strVmDir,m_lstParallelPorts);
}
</xs:documentation>
			<xs:documentation source="m_aDeviceLists">header_fragment:
	// Devices Lists array
	void* m_aDeviceLists[PDE_MAX];
	
	template &lt;typename T&gt;
	QList&lt;T*&gt;* GetDeviceListPtr()
	{
		T objDevice;
		return reinterpret_cast&lt; QList&lt;T*&gt;* &gt;(m_aDeviceLists[ objDevice.getDeviceType() ]);
	}
</xs:documentation>
			<xs:documentation source="CustomInit">header_fragment:
    virtual void CustomInit();</xs:documentation>
			<xs:documentation source="CustomInit_impl">unit_fragment:
void CVmHardware::CustomInit()
{
    m_bAddingTypedDevice = false;
    m_bAddingOpticalDisk = false;
    m_bAddingHardDisk = false;
	memset(m_aDeviceLists, 0, sizeof(m_aDeviceLists));
	m_aDeviceLists[PDE_GENERIC_DEVICE]			= &amp;m_lstGenericDevices;
	m_aDeviceLists[PDE_GENERIC_PCI_DEVICE]		= &amp;m_lstGenericPciDevices;
	m_aDeviceLists[PDE_PCI_VIDEO_ADAPTER]		= &amp;m_lstPciVideoAdapters;
	m_aDeviceLists[PDE_GENERIC_SCSI_DEVICE]		= &amp;m_lstGenericScsiDevices;
	m_aDeviceLists[PDE_FLOPPY_DISK]				= &amp;m_lstFloppyDisks;
	m_aDeviceLists[PDE_OPTICAL_DISK]			= &amp;m_lstOpticalDisks;
	m_aDeviceLists[PDE_HARD_DISK]				= &amp;m_lstHardDisks;
	m_aDeviceLists[PDE_GENERIC_NETWORK_ADAPTER]	= &amp;m_lstNetworkAdapters;
	m_aDeviceLists[PDE_SERIAL_PORT]				= &amp;m_lstSerialPorts;
	m_aDeviceLists[PDE_PARALLEL_PORT]			= &amp;m_lstParallelPorts;
	m_aDeviceLists[PDE_SOUND_DEVICE]			= &amp;m_lstSoundDevices;
	m_aDeviceLists[PDE_USB_DEVICE]				= &amp;m_lstUsbDevices;
}
</xs:documentation>
			<xs:documentation source="CustomCopy">header_fragment:
    virtual void CustomCopy(const CBaseNode* pBN);
</xs:documentation>
			<xs:documentation source="CustomCopy_impl">unit_fragment:
void CVmHardware::CustomCopy(const CBaseNode* pBN)
{
    if ( ! pBN ) return;

    CustomInit();
    CVmHardware&amp; rObject(*(CVmHardware* )pBN); 

    m_bAddingTypedDevice = rObject.m_bAddingTypedDevice;
    m_bAddingOpticalDisk = rObject.m_bAddingOpticalDisk;
    m_bAddingHardDisk = rObject.m_bAddingHardDisk;

    m_lstIdeDevices.clear();
    QList&lt;CVmMassStorageDevice* &gt; lstDevs;

    lstDevs += *( (QList&lt;CVmMassStorageDevice* &gt;* )m_aDeviceLists[PDE_HARD_DISK] );
    lstDevs += *( (QList&lt;CVmMassStorageDevice* &gt;* )m_aDeviceLists[PDE_OPTICAL_DISK] );

     foreach(CVmMassStorageDevice* pDev, lstDevs)
    {
        if (pDev-&gt;getInterfaceType() == PMS_IDE_DEVICE)
            m_lstIdeDevices += pDev;
    }
}
</xs:documentation>
			<xs:documentation source="post read XML actions">post_read_fragment:
	if (Chipset_count &gt;= 1)
	{
		getChipset()-&gt;setType(0);
	}

	m_lstIdeDevices.clear();
	QList&lt;CVmMassStorageDevice* &gt; lstDevs;

	lstDevs += *( (QList&lt;CVmMassStorageDevice* &gt;* )m_aDeviceLists[PDE_HARD_DISK] );
	lstDevs += *( (QList&lt;CVmMassStorageDevice* &gt;* )m_aDeviceLists[PDE_OPTICAL_DISK] );

	foreach(CVmMassStorageDevice* pDev, lstDevs)
	{
		if (pDev-&gt;getInterfaceType() == PMS_IDE_DEVICE)
			m_lstIdeDevices += pDev;
	}

	foreach(CVmSoundDevice* pSD, m_lstSoundDevices)
	{
		if (pSD-&gt;getSoundInputs()-&gt;m_lstSoundDevices.isEmpty())
		{
			pSD-&gt;getSoundInputs()-&gt;m_lstSoundDevices += new CVmSoundDevice();
			pSD-&gt;getSoundInputs()-&gt;m_lstSoundDevices.last()-&gt;setUserFriendlyName(PRL_SOUND_DEFAULT_DEVICE_NAME);
		}
		if (pSD-&gt;getSoundOutputs()-&gt;m_lstSoundDevices.isEmpty())
		{
			pSD-&gt;getSoundOutputs()-&gt;m_lstSoundDevices += new CVmSoundDevice();
			pSD-&gt;getSoundOutputs()-&gt;m_lstSoundDevices.last()-&gt;setUserFriendlyName(PRL_SOUND_DEFAULT_DEVICE_NAME);
		}
	}
</xs:documentation>
			<xs:documentation source="include input/output sound devs">unit_fragment:
#include "CVmSoundInputs.h"
#include "CVmSoundOutputs.h"
</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="Cpu" block="restriction">
				<xs:annotation>
					<xs:documentation>class=CVmCpu;single_fixed=on;</xs:documentation>
					<xs:documentation source="Comparision operator">header_fragment:
    bool    operator==(CVmCpu&amp; cVmCpu);
</xs:documentation>
					<xs:documentation source="Comparision operator_impl">unit_fragment:
bool CVmCpu::operator==(CVmCpu&amp; cVmCpu)
{
	return (
		(getNumber() == cVmCpu.getNumber()) &amp;&amp;
		(getMode() == cVmCpu.getMode()) &amp;&amp;
		(getAccelerationLevel() == cVmCpu.getAccelerationLevel()) &amp;&amp;
		(isEnableHotplug() == cVmCpu.isEnableHotplug()) &amp;&amp;
		(getEnableVTxSupport() == cVmCpu.getEnableVTxSupport())
		);
}
</xs:documentation>
				</xs:annotation>
				<xs:complexType>
					<xs:sequence>
						<xs:element name="Number" type="xs:integer" default="XML_DEFAULT_VM_CPU_NUMBER"/>
						<xs:element name="Mode" type="xs:integer" default="PCM_CPU_MODE_32">
							<xs:annotation>
								<xs:documentation>type=PRL_CPU_MODE;</xs:documentation>
							</xs:annotation>
						</xs:element>
						<xs:element ref="AccelerationLevel"/>
						<xs:element ref="EnableVTxSupport"/>
						<xs:element name="EnableHotplug" type="xs:boolean" default="false" minOccurs="0"/>
						<xs:element name="CpuUnits" type="xs:integer" default="0" minOccurs="0"/>
						<xs:element name="CpuLimit" type="xs:integer" default="0" minOccurs="0">
							<xs:annotation>
								<xs:documentation>include="SDK/Include/PrlIOStructs.h";</xs:documentation>
								<xs:documentation source="Set CpuLimit">header_fragment:
void setCpuLimitPercents(unsigned int value);
							</xs:documentation>
								<xs:documentation source="Set CpuLimit">unit_fragment:
void CVmCpu::setCpuLimitPercents(unsigned int value)
{
	PRL_CPULIMIT_DATA cpulimit;

	cpulimit.value = value;
	cpulimit.type = PRL_CPULIMIT_PERCENTS;

	setCpuLimitData(&amp;cpulimit);
}
								</xs:documentation>
							</xs:annotation>
						</xs:element>
						<xs:element name="CpuLimitType" type="xs:integer" default="PRL_CPULIMIT_MHZ" minOccurs="0">
							<xs:annotation>
								<xs:documentation>type=PRL_CPULIMIT_TYPE;</xs:documentation>
							</xs:annotation>
						</xs:element>
						<xs:element name="CpuLimitValue" type="xs:integer" default="0" minOccurs="0">
							<xs:annotation>
								<xs:documentation source="Set CpuLimitValue">header_fragment:
void setCpuLimitData(PRL_CONST_CPULIMIT_DATA_PTR cpulimit);
void getCpuLimitData(PRL_CPULIMIT_DATA_PTR cpulimit);
								</xs:documentation>
								<xs:documentation source="Set CpuLimitValue">unit_fragment:

void CVmCpu::setCpuLimitData(PRL_CONST_CPULIMIT_DATA_PTR cpulimit)
{
	setCpuLimitValue(cpulimit->value);
	setCpuLimitType(cpulimit->type);

	if (cpulimit->type == PRL_CPULIMIT_MHZ)
		setCpuLimit(0);
	else if (cpulimit->type == PRL_CPULIMIT_PERCENTS)
		setCpuLimit(cpulimit->value);
}

void CVmCpu::getCpuLimitData(PRL_CPULIMIT_DATA_PTR cpulimit)
{
	cpulimit->value = getCpuLimitValue();
	cpulimit->type = getCpuLimitType();

}
								</xs:documentation>
							</xs:annotation>
						</xs:element>
						<xs:element name="CpuMask" type="xs:string" minOccurs="0"/>
						<xs:element name="VirtualizedHV" type="xs:boolean" minOccurs="0"/>
						<xs:element name="VirtualizePMU" type="xs:boolean" default="false" minOccurs="0"/>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<xs:element name="Chipset">
				<xs:annotation>
					<xs:documentation>single_fixed=on;</xs:documentation>
				</xs:annotation>
				<xs:complexType>
					<xs:sequence>
						<xs:element name="Type" type="xs:integer" default="1"/>
						<xs:element name="Version" type="xs:integer" default="3" minOccurs="0">
							<xs:annotation>
								<xs:documentation/>
								<xs:documentation source="patch on">patch:</xs:documentation>
							</xs:annotation>
						</xs:element>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<xs:element name="Clock">
				<xs:annotation>
					<xs:documentation>single_fixed=on;</xs:documentation>
				</xs:annotation>
				<xs:complexType>
					<xs:sequence>
						<xs:element name="TimeShift" type="xs:long" default="0"/>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<xs:element name="Memory" type="MemoryType">
				<xs:annotation>
					<xs:documentation>single_fixed=on;</xs:documentation>
					<xs:documentation source="Comparison operator">header_fragment:
    bool    operator==(CVmMemory&amp; cVmMemory);
</xs:documentation>
					<xs:documentation source="Comparison operator_impl">unit_fragment:
bool CVmMemory::operator==(CVmMemory&amp; cVmMemory)
{
    return ( getRamSize() == cVmMemory.getRamSize() );
}
</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Video" block="restriction">
				<xs:annotation>
					<xs:documentation>class=CVmVideo;single_fixed=on;</xs:documentation>
				</xs:annotation>
				<xs:complexType>
					<xs:sequence>
						<xs:element name="Enabled" type="xs:boolean" default="true" minOccurs="0"/>
						<xs:element name="VideoMemorySize" type="xs:integer" default="XML_DEFAULT_VIDEO_SIZE">
							<xs:annotation>
								<xs:documentation>method=MemorySize;</xs:documentation>
								<xs:documentation source="patch on">patch:</xs:documentation>
							</xs:annotation>
						</xs:element>
						<xs:element name="EnableDirectXShaders" type="xs:boolean" default="true"/>
						<xs:element name="ScreenResolutions" type="ScreenResolutionsType">
							<xs:annotation>
								<xs:documentation>method=VmScreenResolutions;single_fixed=on;</xs:documentation>
							</xs:annotation>
						</xs:element>
						<xs:element name="Enable3DAcceleration" type="xs:integer" default="P3D_ENABLED_HIGHEST" minOccurs="0">
							<xs:annotation>
								<xs:documentation>type=PRL_VIDEO_3D_ACCELERATION;</xs:documentation>
							</xs:annotation>
						</xs:element>
						<xs:element name="EnableVSync" type="xs:boolean" default="true" minOccurs="0"/>
						<xs:element name="MaxDisplays" type="xs:integer" minOccurs="0"/>
						<xs:element name="EnableHiResDrawing" type="xs:boolean" default="true" minOccurs="0"/>
						<xs:element name="UseHiResInGuest" type="xs:boolean" default="true" minOccurs="0"/>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<xs:element name="Fdd" type="FddType" block="restriction" minOccurs="0">
				<xs:annotation>
					<xs:documentation>list=FloppyDisks;</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="CdRom" type="CdRomType" block="restriction" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>list=OpticalDisks;</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Hdd" type="HddType" block="restriction" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>list=HardDisks;</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Serial" type="SerialType" block="restriction" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>list=SerialPorts;</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Parallel" type="ParallelType" block="restriction" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>list=ParallelPortOlds;</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Printer" type="PrinterType" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>list=ParallelPorts;</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="NetworkAdapter" type="NetworkAdapterType" block="restriction" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>list=NetworkAdapters;</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Sound" type="SoundType" block="restriction" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>list=SoundDevices;</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="USB" block="restriction" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>list=UsbDevices;</xs:documentation>
				</xs:annotation>
				<xs:complexType>
					<xs:complexContent>
						<xs:extension base="USBType"/>
					</xs:complexContent>
				</xs:complexType>
			</xs:element>
			<xs:element name="PciVideoAdapter" type="PciVideoAdapterType" block="restriction" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>list=PciVideoAdapters;</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="GenericDevice" block="restriction" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>class=CVmGenericDevice;base_class=CVmClusteredDevice;list=GenericDevices;object_id=on;</xs:documentation>
					<xs:documentation source="getEmulatedType">header_fragment:
    PVE::GenericDeviceEmulatedType getEmulatedType() const { return (PVE::GenericDeviceEmulatedType )CVmDevice::getEmulatedType(); }
</xs:documentation>
				</xs:annotation>
				<xs:complexType>
					<xs:sequence>
						<xs:element name="Index" type="xs:integer">
							<xs:annotation>
								<xs:documentation>attribute=index;method_base_class=CVmDevice;</xs:documentation>
							</xs:annotation>
						</xs:element>
						<xs:element name="Enabled" type="xs:integer">
							<xs:annotation>
								<xs:documentation>method_base_class=CVmDevice;type=PVE::DeviceEnabledState;</xs:documentation>
							</xs:annotation>
						</xs:element>
						<xs:element name="Connected" type="xs:integer">
							<xs:annotation>
								<xs:documentation>method_base_class=CVmDevice;type=PVE::DeviceConnectedState;</xs:documentation>
							</xs:annotation>
						</xs:element>
						<xs:element name="EmulatedType" type="xs:integer">
							<xs:annotation>
								<xs:documentation>method_base_class=CVmDevice;default=PVE::RealGenericDevice;</xs:documentation>
							</xs:annotation>
						</xs:element>
						<xs:element name="SystemName" type="xs:string">
							<xs:annotation>
								<xs:documentation>method_base_class=CVmDevice;</xs:documentation>
							</xs:annotation>
						</xs:element>
						<xs:element name="UserFriendlyName" type="xs:string">
							<xs:annotation>
								<xs:documentation>method_base_class=CVmDevice;</xs:documentation>
							</xs:annotation>
						</xs:element>
						<xs:element name="Remote" type="xs:boolean">
							<xs:annotation>
								<xs:documentation>method_base_class=CVmDevice;</xs:documentation>
							</xs:annotation>
						</xs:element>
						<xs:element name="InterfaceType" type="xs:integer">
							<xs:annotation>
								<xs:documentation>method_base_class=CVmClusteredDevice;default=PVE::GenericDeviceScsi;type=PRL_MASS_STORAGE_INTERFACE_TYPE;</xs:documentation>
							</xs:annotation>
						</xs:element>
						<xs:element name="StackIndex" type="xs:integer">
							<xs:annotation>
								<xs:documentation>method_base_class=CVmClusteredDevice;</xs:documentation>
							</xs:annotation>
						</xs:element>
						<xs:element name="DeviceDescription" type="xs:string" minOccurs="0">
							<xs:annotation>
								<xs:documentation>method=Description;method_base_class=CVmDevice;</xs:documentation>
							</xs:annotation>
						</xs:element>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<xs:element name="GenericPciDevice" block="restriction" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>class=CVmGenericPciDevice;base_class=CVmClusteredDevice;list=GenericPciDevices;object_id=on;</xs:documentation>
					<xs:documentation source="getDeviceType">header_fragment:
    virtual PRL_DEVICE_TYPE getDeviceType() const { return PDE_GENERIC_PCI_DEVICE; }
</xs:documentation>
					<xs:documentation source="getEmulatedType">header_fragment:
    PVE::GenericDeviceEmulatedType getEmulatedType() const { return (PVE::GenericDeviceEmulatedType )CVmDevice::getEmulatedType(); }
</xs:documentation>
				</xs:annotation>
				<xs:complexType>
					<xs:sequence>
						<xs:element name="Index" type="xs:integer">
							<xs:annotation>
								<xs:documentation>attribute=index;method_base_class=CVmDevice;</xs:documentation>
							</xs:annotation>
						</xs:element>
						<xs:element name="Enabled" type="xs:integer">
							<xs:annotation>
								<xs:documentation>method_base_class=CVmDevice;type=PVE::DeviceEnabledState;</xs:documentation>
							</xs:annotation>
						</xs:element>
						<xs:element name="Connected" type="xs:integer">
							<xs:annotation>
								<xs:documentation>method_base_class=CVmDevice;type=PVE::DeviceConnectedState;</xs:documentation>
							</xs:annotation>
						</xs:element>
						<xs:element name="EmulatedType" type="xs:integer">
							<xs:annotation>
								<xs:documentation>method_base_class=CVmDevice;default=PVE::RealGenericDevice;</xs:documentation>
							</xs:annotation>
						</xs:element>
						<xs:element name="SystemName" type="xs:string">
							<xs:annotation>
								<xs:documentation>method_base_class=CVmDevice;</xs:documentation>
							</xs:annotation>
						</xs:element>
						<xs:element name="UserFriendlyName" type="xs:string">
							<xs:annotation>
								<xs:documentation>method_base_class=CVmDevice;</xs:documentation>
							</xs:annotation>
						</xs:element>
						<xs:element name="Remote" type="xs:boolean">
							<xs:annotation>
								<xs:documentation>method_base_class=CVmDevice;</xs:documentation>
							</xs:annotation>
						</xs:element>
						<xs:element name="InterfaceType" type="xs:integer">
							<xs:annotation>
								<xs:documentation>method_base_class=CVmClusteredDevice;default=PVE::GenericDevicePci;type=PRL_MASS_STORAGE_INTERFACE_TYPE;</xs:documentation>
							</xs:annotation>
						</xs:element>
						<xs:element name="StackIndex" type="xs:integer">
							<xs:annotation>
								<xs:documentation>method_base_class=CVmClusteredDevice;</xs:documentation>
							</xs:annotation>
						</xs:element>
						<xs:element name="Type" type="xs:integer" default="PGD_PCI_NETWORK" minOccurs="0">
							<xs:annotation>
								<xs:documentation>type=PRL_GENERIC_PCI_DEVICE_CLASS;</xs:documentation>
							</xs:annotation>
						</xs:element>
						<xs:element name="DeviceDescription" type="xs:string">
							<xs:annotation>
								<xs:documentation>method=Description;method_base_class=CVmDevice;</xs:documentation>
							</xs:annotation>
						</xs:element>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<xs:element name="GenericScsiDevice" block="restriction" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>class=CVmGenericScsiDevice;base_class=CVmMassStorageDevice;list=GenericScsiDevices;object_id=on;</xs:documentation>
					<xs:documentation source="getDeviceType">header_fragment:
    virtual PRL_DEVICE_TYPE getDeviceType() const { return PDE_GENERIC_SCSI_DEVICE; }
</xs:documentation>
					<xs:documentation source="getEmulatedType">header_fragment:
    PVE::GenericDeviceEmulatedType getEmulatedType() const { return (PVE::GenericDeviceEmulatedType )CVmDevice::getEmulatedType(); }
</xs:documentation>
				</xs:annotation>
				<xs:complexType>
					<xs:sequence>
						<xs:element name="Index" type="xs:integer">
							<xs:annotation>
								<xs:documentation>attribute=index;method_base_class=CVmDevice;</xs:documentation>
							</xs:annotation>
						</xs:element>
						<xs:element name="Enabled" type="xs:integer">
							<xs:annotation>
								<xs:documentation>method_base_class=CVmDevice;type=PVE::DeviceEnabledState;</xs:documentation>
							</xs:annotation>
						</xs:element>
						<xs:element name="Connected" type="xs:integer">
							<xs:annotation>
								<xs:documentation>method_base_class=CVmDevice;type=PVE::DeviceConnectedState;</xs:documentation>
							</xs:annotation>
						</xs:element>
						<xs:element name="EmulatedType" type="xs:integer">
							<xs:annotation>
								<xs:documentation>method_base_class=CVmDevice;default=PVE::RealGenericDevice;</xs:documentation>
							</xs:annotation>
						</xs:element>
						<xs:element name="SystemName" type="xs:string">
							<xs:annotation>
								<xs:documentation>method_base_class=CVmDevice;</xs:documentation>
							</xs:annotation>
						</xs:element>
						<xs:element name="UserFriendlyName" type="xs:string">
							<xs:annotation>
								<xs:documentation>method_base_class=CVmDevice;</xs:documentation>
							</xs:annotation>
						</xs:element>
						<xs:element name="Remote" type="xs:boolean">
							<xs:annotation>
								<xs:documentation>method_base_class=CVmDevice;</xs:documentation>
							</xs:annotation>
						</xs:element>
						<xs:element name="InterfaceType" type="xs:integer">
							<xs:annotation>
								<xs:documentation>method_base_class=CVmClusteredDevice;default=PMS_SCSI_DEVICE;type=PRL_MASS_STORAGE_INTERFACE_TYPE;</xs:documentation>
							</xs:annotation>
						</xs:element>
						<xs:element name="StackIndex" type="xs:integer">
							<xs:annotation>
								<xs:documentation>method_base_class=CVmClusteredDevice;</xs:documentation>
							</xs:annotation>
						</xs:element>
						<xs:element name="Passthrough" type="xs:integer">
							<xs:annotation>
								<xs:documentation>method_base_class=CVmClusteredDevice;type=PVE::DevicePassthroughMode;</xs:documentation>
							</xs:annotation>
						</xs:element>
						<xs:element name="SubType" type="xs:integer" minOccurs="0">
							<xs:annotation>
								<xs:documentation>method_base_class=CVmClusteredDevice;type=PRL_CLUSTERED_DEVICE_SUBTYPE;</xs:documentation>
							</xs:annotation>
						</xs:element>
						<xs:element name="DeviceDescription" type="xs:string">
							<xs:annotation>
								<xs:documentation>method=Description;method_base_class=CVmDevice;</xs:documentation>
							</xs:annotation>
						</xs:element>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
		</xs:sequence>
	</xs:complexType>
	<xs:complexType name="HddType">
		<xs:annotation>
			<xs:documentation>class=CVmHardDisk;base_class=CVmMassStorageDevice;object_id=on;</xs:documentation>
			<xs:documentation source="Comparision operator">header_fragment:
    virtual bool operator==( const CVmHardDisk&amp; cVmHardDisk );
</xs:documentation>
			<xs:documentation source="Comparision operator_impl">unit_fragment:
bool CVmHardDisk::operator==( const CVmHardDisk&amp; cVmHardDisk )
{
	if (CVmMassStorageDevice::operator ==(cVmHardDisk))
	{
		if (
			(isSplitted() == cVmHardDisk.isSplitted()) &amp;&amp;
			(getDiskType() == cVmHardDisk.getDiskType()) &amp;&amp;
			(getSize() == cVmHardDisk.getSize()) &amp;&amp;
			(getVersion() == cVmHardDisk.getVersion())
			)
			return true;
		
	}
	return false;
}
</xs:documentation>
			<xs:documentation source="getDeviceType">header_fragment:
    virtual PRL_DEVICE_TYPE getDeviceType() const { return PDE_HARD_DISK; }
</xs:documentation>
			<xs:documentation source="getEmulatedType">header_fragment:
    PVE::HardDiskEmulatedType getEmulatedType() const { return (PVE::HardDiskEmulatedType )CVmDevice::getEmulatedType(); }
</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="Uuid" type="xs:string" minOccurs="0">
				<xs:annotation>
					<xs:documentation>default=Uuid::createUuid().toString()</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="MountPoint" type="xs:string" minOccurs="0">
				<xs:annotation>
					<xs:documentation>no_save=on</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Index" type="xs:integer">
				<xs:annotation>
					<xs:documentation>attribute=index;method_base_class=CVmDevice;</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Enabled" type="xs:integer">
				<xs:annotation>
					<xs:documentation>method_base_class=CVmDevice;type=PVE::DeviceEnabledState;</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Connected" type="xs:integer">
				<xs:annotation>
					<xs:documentation>method_base_class=CVmDevice;type=PVE::DeviceConnectedState;</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="EmulatedType" type="xs:integer">
				<xs:annotation>
					<xs:documentation>method_base_class=CVmDevice;default=PVE::HardDiskImage;</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="SystemName" type="xs:string">
				<xs:annotation>
					<xs:documentation>method_base_class=CVmDevice;</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="UserFriendlyName" type="xs:string">
				<xs:annotation>
					<xs:documentation>method_base_class=CVmDevice;</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Remote" type="xs:boolean">
				<xs:annotation>
					<xs:documentation>method_base_class=CVmDevice;</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="InterfaceType" type="xs:integer">
				<xs:annotation>
					<xs:documentation>method_base_class=CVmClusteredDevice;type=PRL_MASS_STORAGE_INTERFACE_TYPE;</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="StackIndex" type="xs:integer">
				<xs:annotation>
					<xs:documentation>method_base_class=CVmClusteredDevice;</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="DiskType" type="xs:integer" default="PHD_EXPANDING_HARD_DISK">
				<xs:annotation>
					<xs:documentation>type=PRL_HARD_DISK_INTERNAL_FORMAT;</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Size" type="xs:integer">
				<xs:annotation>
					<xs:documentation>type=unsigned long;</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="SizeOnDisk" type="xs:integer" fixed="read_only_for_merge">
				<xs:annotation>
					<xs:documentation>type=unsigned long;</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Passthrough" type="xs:integer">
				<xs:annotation>
					<xs:documentation>method_base_class=CVmClusteredDevice;type=PVE::DevicePassthroughMode;</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="SubType" type="xs:integer" minOccurs="0">
				<xs:annotation>
					<xs:documentation>method_base_class=CVmClusteredDevice;type=PRL_CLUSTERED_DEVICE_SUBTYPE;</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Splitted" type="xs:boolean"/>
			<xs:element name="DiskVersion" type="xs:int" default="PVE::HardDiskV2" minOccurs="0">
				<xs:annotation>
					<xs:documentation>method=Version;type=PVE::HardDiskVersion;</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="CompatLevel" type="xs:string" minOccurs="0"/>
			<xs:element name="Partition" type="PartitionType" minOccurs="0" maxOccurs="unbounded"/>
			<xs:element name="DeviceDescription" type="xs:string" minOccurs="0">
				<xs:annotation>
					<xs:documentation>method=Description;method_base_class=CVmDevice;</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Password" type="xs:string" minOccurs="0">
				<xs:annotation>
					<xs:documentation>no_save=on</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Encrypted" type="xs:boolean" minOccurs="0">
				<xs:annotation>
					<xs:documentation>no_save=on</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="BlockSize" type="xs:integer" default="0" minOccurs="0">
				<xs:annotation>
					<xs:documentation>no_save=on</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="AutoCompressEnabled" type="xs:boolean" default="true" minOccurs="0"/>
			<xs:element name="StorageURL" type="xs:anyURI" minOccurs="0"/>
		</xs:sequence>
	</xs:complexType>
	<xs:element name="Height" type="xs:integer"/>
	<xs:element name="Icon" type="xs:string"/>
	<xs:complexType name="IdentificationType">
		<xs:annotation>
			<xs:documentation>class=CVmIdentification;</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element ref="VmUuid"/>
			<xs:element name="SourceVmUuid" type="xs:string" minOccurs="0"/>
			<xs:element name="LinkedVmUuid" type="xs:string" minOccurs="0"/>
			<xs:element ref="VmName"/>
			<xs:element ref="ServerUuid"/>
			<xs:element ref="LastServerUuid" minOccurs="0"/>
			<xs:element ref="ServerHost"/>
			<xs:element ref="VmHome" minOccurs="0"/>
			<xs:element name="VmFilesLocation" type="xs:integer" default="PVL_UNKNOWN" minOccurs="0">
				<xs:annotation>
					<xs:documentation>type=PRL_VM_LOCATION;</xs:documentation>
					<xs:documentation source="Tag condition">condition:m_ctVmFilesLocation != PVL_UNKNOWN</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element ref="ChangedBy" minOccurs="0"/>
			<xs:element ref="ChangeDateTime" minOccurs="0"/>
			<xs:element name="VmCreationDate" type="xs:dateTime" default="QDateTime::currentDateTime()" minOccurs="0">
				<xs:annotation>
					<xs:documentation>method=CreationDate;default=QDateTime::fromString( XML_DEFAULT_DATE_TIME, XML_DATETIME_FORMAT );</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="VmUptimeStartDateTime" type="xs:dateTime" default="QDateTime::currentDateTime().toUTC()" minOccurs="0"/>
			<xs:element name="VmUptimeInSeconds" type="xs:integer" default="0" minOccurs="0">
				<xs:annotation>
					<xs:documentation>type=quint64;</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="EnvId" type="xs:integer" default="0" minOccurs="0"/>
		</xs:sequence>
	</xs:complexType>
	<xs:element name="InUse" type="xs:boolean"/>
	<xs:element name="InterfaceType" type="xs:integer"/>
	<xs:element name="MAC" type="xs:string">
		<xs:annotation>
			<xs:documentation>method=MacAddress;</xs:documentation>
		</xs:annotation>
	</xs:element>
	<xs:element name="HostMAC" type="xs:string">
		<xs:annotation>
			<xs:documentation>method=HostMacAddress;</xs:documentation>
		</xs:annotation>
	</xs:element>
	<xs:complexType name="MemoryType">
		<xs:annotation>
			<xs:documentation>class=CVmMemory;</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element ref="RAM"/>
			<xs:element name="EnableHotplug" type="xs:boolean" default="false" minOccurs="0"/>
			<xs:element name="HostMemQuotaMin" type="xs:integer" minOccurs="0">
				<xs:annotation>
					<xs:documentation>default=qMin((int )getRamSize() / 2, XML_DEFAULT_QUOTA_MIN_SIZE);</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="HostMemQuotaMax" type="xs:integer" default="(unsigned int )-1" minOccurs="0"/>
			<xs:element name="HostMemQuotaPriority" type="xs:integer" default="XML_DEFAULT_QUOTA_PRIORITY" minOccurs="0"/>
			<xs:element name="AutoQuota" type="xs:boolean" default="true" minOccurs="0"/>
			<xs:element name="MaxBalloonSize" type="xs:integer" default="70" minOccurs="0"/>
		</xs:sequence>
	</xs:complexType>
	<xs:element name="Mixer" type="xs:string"/>
	<xs:element name="MultiDisplay" type="xs:boolean" default="XML_DEFAULT_CHRN_MULTIDISPLAY">
		<xs:annotation>
			<xs:documentation/>
			<xs:documentation source="patch on">patch:</xs:documentation>
		</xs:annotation>
	</xs:element>
	<xs:complexType name="NetAddressType">
		<xs:annotation>
			<xs:documentation>class=CVmNetAddress;</xs:documentation>
		</xs:annotation>
	</xs:complexType>
	<xs:complexType name="NetFirewallType">
		<xs:annotation>
			<xs:documentation>class=CVmNetFirewall;</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="Enabled" type="xs:boolean" minOccurs="0"/>
			<xs:element name="Incoming">
				<xs:annotation>
					<xs:documentation>single_fixed=on;class=CVmNetFirewallIncoming</xs:documentation>
				</xs:annotation>
				<xs:complexType>
					<xs:sequence>
						<xs:element name="Direction" type="NetFirewallDirectionType">
							<xs:annotation>
								<xs:documentation>single_fixed=on;</xs:documentation>
							</xs:annotation>
						</xs:element>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<xs:element name="Outgoing">
				<xs:annotation>
					<xs:documentation>single_fixed=on;class=CVmNetFirewallOutgoing</xs:documentation>
				</xs:annotation>
				<xs:complexType>
					<xs:sequence>
						<xs:element name="Direction" type="NetFirewallDirectionType">
							<xs:annotation>
								<xs:documentation>single_fixed=on;</xs:documentation>
							</xs:annotation>
						</xs:element>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
		</xs:sequence>
	</xs:complexType>
	<xs:complexType name="NetFirewallDirectionType">
		<xs:annotation>
			<xs:documentation>class=CVmNetFirewallDirection;</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="DefaultPolicy" type="xs:integer" default="PFP_ACCEPT" minOccurs="0">
				<xs:annotation>
					<xs:documentation>type=PRL_FIREWALL_POLICY;</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="FirewallRules" type="NetFirewallRulesType">
				<xs:annotation>
					<xs:documentation>single_fixed=on</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
	</xs:complexType>
	<xs:complexType name="NetFirewallRulesType">
		<xs:annotation>
			<xs:documentation>class=CVmNetFirewallRules;</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="FirewallRule" type="NetFirewallRuleType" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>list=FirewallRules;</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
	</xs:complexType>
	<xs:complexType name="NetFirewallRuleType">
		<xs:annotation>
			<xs:documentation>class=CVmNetFirewallRule;</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="Protocol" type="xs:string" minOccurs="0"/>
			<xs:element name="LocalNetAddress" type="xs:string" minOccurs="0"/>
			<xs:element name="LocalPort" type="xs:integer" minOccurs="0"/>
			<xs:element name="RemoteNetAddress" type="xs:string" minOccurs="0"/>
			<xs:element name="RemotePort" type="xs:integer" minOccurs="0"/>
		</xs:sequence>
	</xs:complexType>
	<xs:complexType name="NetworkAdapterType">
		<xs:annotation>
			<xs:documentation>class=CVmGenericNetworkAdapter;base_class=CVmClusteredDevice;object_id=on;</xs:documentation>
			<xs:documentation source="Comparision operator">header_fragment:
    virtual bool operator==( const CVmGenericNetworkAdapter&amp; cVmGenericNetworkAdapter);
</xs:documentation>
			<xs:documentation source="Comparision operator_impl">unit_fragment:
bool CVmGenericNetworkAdapter::operator==( const CVmGenericNetworkAdapter&amp; cVmGenericNetworkAdapter)
{
    if ( !CVmClusteredDevice::operator ==(cVmGenericNetworkAdapter) )
        return false;

    if (getBoundAdapterIndex() == cVmGenericNetworkAdapter.getBoundAdapterIndex()
        &amp;&amp; getBoundAdapterName() == cVmGenericNetworkAdapter.getBoundAdapterName()
        &amp;&amp; getVirtualNetworkID() == cVmGenericNetworkAdapter.getVirtualNetworkID()
        &amp;&amp; getMacAddress() == cVmGenericNetworkAdapter.getMacAddress()
        &amp;&amp; isRouter() == cVmGenericNetworkAdapter.isRouter()
        &amp;&amp; getDHCPUseHostMac() == cVmGenericNetworkAdapter.getDHCPUseHostMac()
        &amp;&amp; getNetAddresses() == cVmGenericNetworkAdapter.getNetAddresses()
        &amp;&amp; isAutoApply() == cVmGenericNetworkAdapter.isAutoApply()
        &amp;&amp; getDefaultGateway() == cVmGenericNetworkAdapter.getDefaultGateway()
        &amp;&amp; getDnsIPAddresses() == cVmGenericNetworkAdapter.getDnsIPAddresses()
        &amp;&amp; getSearchDomains() == cVmGenericNetworkAdapter.getSearchDomains()
        &amp;&amp; isConfigureWithDhcp() == cVmGenericNetworkAdapter.isConfigureWithDhcp()
        &amp;&amp; isConfigureWithDhcpIPv6() == cVmGenericNetworkAdapter.isConfigureWithDhcpIPv6()
        &amp;&amp; getAdapterType() == cVmGenericNetworkAdapter.getAdapterType()
	&amp;&amp; *getPktFilter() == *cVmGenericNetworkAdapter.getPktFilter())
    {
        return true;
    }

    return false;
}
</xs:documentation>
			<xs:documentation source="isIPv6">header_fragment:
    bool isIPv6(const QString &amp;ip);
</xs:documentation>
			<xs:documentation source="isIPv6_impl">unit_fragment:
bool CVmGenericNetworkAdapter::isIPv6(const QString &amp;ip)
{
	return (ip.indexOf(':') >= 0);
}
</xs:documentation>
			<xs:documentation source="setConfigureWithDhcpEx">header_fragment:
    void setConfigureWithDhcpEx(bool value);
</xs:documentation>
			<xs:documentation source="setConfigureWithDhcpEx_impl">unit_fragment:
void CVmGenericNetworkAdapter::setConfigureWithDhcpEx(bool value)
{
	setConfigureWithDhcp(value);
	if (value)
	{	//clean v4 IPs
		QList&lt;QString&gt; lstNetAddress = getNetAddresses();
		for(int i = lstNetAddress.size()-1; i >= 0; i--)
			if (!isIPv6(lstNetAddress[i]))
				lstNetAddress.removeAt(i);
		setNetAddresses(lstNetAddress);
	}
}
</xs:documentation>
			<xs:documentation source="setConfigureWithDhcpIPv6Ex">header_fragment:
    void setConfigureWithDhcpIPv6Ex(bool value);
</xs:documentation>
			<xs:documentation source="setConfigureWithDhcpIPv6Ex_impl">unit_fragment:
void CVmGenericNetworkAdapter::setConfigureWithDhcpIPv6Ex(bool value)
{
	setConfigureWithDhcpIPv6(value);
	if (value)
	{	//clean v6 IPs
		QList&lt;QString&gt; lstNetAddress = getNetAddresses();
		for(int i = lstNetAddress.size()-1; i >= 0; i--)
			if (isIPv6(lstNetAddress[i]))
				lstNetAddress.removeAt(i);
		setNetAddresses(lstNetAddress);
	}
}
</xs:documentation>
			<xs:documentation source="getDeviceType">header_fragment:
    virtual PRL_DEVICE_TYPE getDeviceType() const { return PDE_GENERIC_NETWORK_ADAPTER; }
</xs:documentation>
			<xs:documentation source="getEmulatedType">header_fragment:
    PRL_NET_ADAPTER_EMULATED_TYPE getEmulatedType() const { return (PRL_NET_ADAPTER_EMULATED_TYPE )CVmDevice::getEmulatedType(); }
</xs:documentation>
			<xs:documentation source="isVtdDevice">header_fragment:
    bool isVtdDevice() const { return (PNA_DIRECT_ASSIGN == (PRL_NET_ADAPTER_EMULATED_TYPE)CVmDevice::getEmulatedType()); }
</xs:documentation>
			<xs:documentation source="isVenetDevice">header_fragment:
    bool isVenetDevice() const { return (PNA_ROUTED == (PRL_NET_ADAPTER_EMULATED_TYPE)CVmDevice::getEmulatedType()); }
</xs:documentation>
			<xs:documentation source="include host utils">unit_fragment:
#include "Libraries/HostUtils/HostUtils.h"</xs:documentation>
			<xs:documentation source="post read: drop DHCP flag">post_read_fragment:
    if ( isConfigureWithDhcp() )
    {   //if exist v4 ip - set v4 dhcp to false
	foreach(const QString &amp;ip, m_lstNetAddress)
	{
		if ( !isIPv6(ip) )
		{
        		setConfigureWithDhcp( false );
			break;
		}
	}

    }</xs:documentation>
			<xs:documentation source="post read: drop DHCP IPv6 flag">post_read_fragment:
    if ( isConfigureWithDhcpIPv6() )
    {   //if exist v6 ip - set v6 dhcp to false
	foreach(const QString &amp;ip, m_lstNetAddress)
	{
		if ( isIPv6(ip) )
		{
        		setConfigureWithDhcpIPv6( false );
			break;
		}
	}
    }</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="Index" type="xs:integer">
				<xs:annotation>
					<xs:documentation>attribute=index;method_base_class=CVmDevice;</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Enabled" type="xs:integer">
				<xs:annotation>
					<xs:documentation>method_base_class=CVmDevice;type=PVE::DeviceEnabledState;</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Connected" type="xs:integer">
				<xs:annotation>
					<xs:documentation>method_base_class=CVmDevice;type=PVE::DeviceConnectedState;</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="EmulatedType" type="xs:integer">
				<xs:annotation>
					<xs:documentation>method_base_class=CVmDevice;default=PNA_BRIDGED_ETHERNET;</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="SystemName" type="xs:string">
				<xs:annotation>
					<xs:documentation>method_base_class=CVmDevice;</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="UserFriendlyName" type="xs:string">
				<xs:annotation>
					<xs:documentation>method_base_class=CVmDevice;</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Remote" type="xs:boolean">
				<xs:annotation>
					<xs:documentation>method_base_class=CVmDevice;</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element ref="AdapterNumber"/>
			<xs:element ref="AdapterName"/>
			<xs:element ref="MAC" minOccurs="0"/>
			<xs:element ref="HostMAC" minOccurs="0"/>
			<xs:element name="HostInterfaceName" type="xs:string" minOccurs="0"/>
			<xs:element name="Router" type="xs:boolean" minOccurs="0"/>
			<xs:element name="DHCPUseHostMac" type="xs:integer" default="PNWR_AUTO" minOccurs="0"/>
			<xs:element name="ForceHostMacAddress" type="xs:boolean" default="false" minOccurs="0"/>
			<xs:element name="VirtualNetworkID" type="xs:string" minOccurs="0"/>
			<xs:element name="AdapterType" type="xs:integer" default="PNT_UNDEFINED" minOccurs="0">
				<xs:annotation>
					<xs:documentation>type=PRL_VM_NET_ADAPTER_TYPE;</xs:documentation>
					<xs:documentation>Emulated type of network-adapter. e1000/rtl</xs:documentation>
					<xs:documentation source="patch from text format to enum format">patch:
	if ( AdapterType_patch_stamp != "1" &amp;&amp; AdapterType_count &lt; 0 )
	{
		QString value = RootElement-&gt;firstChildElement("AdapterType").firstChild().toText().data();
		if ( value == "e1000" )
			setAdapterType(PNT_E1000);
		else if ( value == "rtl" )
			setAdapterType(PNT_RTL);
		else if ( value.isEmpty() )
			setAdapterType(PNT_UNDEFINED);
		AdapterType_patch_stamp = "1";
	}</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="StaticAddress" type="xs:boolean" minOccurs="0">
				<xs:annotation>
					<xs:documentation>If true, then the MAC-address of adapter will not be regenerated on import of VM</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="PktFilter">
				<xs:annotation>
					<xs:documentation>single_fixed=on;</xs:documentation>
				</xs:annotation>
				<xs:complexType>
					<xs:complexContent>
						<xs:extension base="NetPktFilterType"/>
					</xs:complexContent>
				</xs:complexType>
			</xs:element>
			<xs:element name="AutoApply" type="xs:boolean" minOccurs="0"/>
			<xs:element name="NetAddress" type="xs:string" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>method=NetAddresses; Format "1.2.3.4/255.255.0.0"</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="ConfigureWithDhcp" type="xs:boolean" minOccurs="0"/>
			<xs:element name="DefaultGateway" type="xs:string" minOccurs="0"/>
			<xs:element name="ConfigureWithDhcpIPv6" type="xs:boolean" minOccurs="0"/>
			<xs:element name="DefaultGatewayIPv6" type="xs:string" minOccurs="0"/>
			<xs:element name="DnsIPAddress" type="xs:string" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>method=DnsIPAddresses; Need for Windows OS, per adapter option.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="SearchDomain" type="xs:string" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>method=SearchDomains; Need for Windows OS, per adapter option.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Firewall" type="NetFirewallType">
				<xs:annotation>
					<xs:documentation>single_fixed=on;</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="DeviceDescription" type="xs:string" minOccurs="0">
				<xs:annotation>
					<xs:documentation>method=Description;method_base_class=CVmDevice;</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
	</xs:complexType>
	<xs:element name="OnAppQuit" type="xs:integer"/>
	<xs:element name="OnPause" type="xs:integer"/>
	<xs:element name="OnStop" type="xs:integer"/>
	<xs:element name="OsType" type="xs:integer"/>
	<xs:element name="Output" type="xs:string"/>
	<xs:complexType name="ParallelType">
		<xs:annotation>
			<xs:documentation>class=CVmParallelPortOld;base_class=CVmPort;object_id=on;</xs:documentation>
			<xs:documentation source="Comparision operator">header_fragment:
    virtual bool operator==( const CVmParallelPortOld&amp; cVmParallelPort );
</xs:documentation>
			<xs:documentation source="Comparision operator_impl">unit_fragment:
bool CVmParallelPortOld::operator==( const CVmParallelPortOld&amp; cVmParallelPort )
{
	return CVmPort::operator ==(cVmParallelPort);
}
</xs:documentation>
			<xs:documentation source="getDeviceType">header_fragment:
    virtual PRL_DEVICE_TYPE getDeviceType() const { return PDE_PARALLEL_PORT; }
</xs:documentation>
			<xs:documentation source="getEmulatedType">header_fragment:
    PVE::ParallelPortEmulatedType getEmulatedType() const { return (PVE::ParallelPortEmulatedType )CVmDevice::getEmulatedType(); }
</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="Index" type="xs:integer">
				<xs:annotation>
					<xs:documentation>attribute=index;method_base_class=CVmDevice;</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Enabled" type="xs:integer">
				<xs:annotation>
					<xs:documentation>method_base_class=CVmDevice;type=PVE::DeviceEnabledState;</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Connected" type="xs:integer">
				<xs:annotation>
					<xs:documentation>method_base_class=CVmDevice;type=PVE::DeviceConnectedState;</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="EmulatedType" type="xs:integer">
				<xs:annotation>
					<xs:documentation>method_base_class=CVmDevice;default=PVE::RealParallelPort;</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="SystemName" type="xs:string">
				<xs:annotation>
					<xs:documentation>method_base_class=CVmDevice;</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="UserFriendlyName" type="xs:string">
				<xs:annotation>
					<xs:documentation>method_base_class=CVmDevice;</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Remote" type="xs:boolean">
				<xs:annotation>
					<xs:documentation>method_base_class=CVmDevice;</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="PrinterInterfaceType" type="xs:integer" default="PRN_USB_DEVICE" minOccurs="0">
				<xs:annotation>
					<xs:documentation>type=PRL_PRINTER_INTERFACE_TYPE;</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="DeviceDescription" type="xs:string" minOccurs="0">
				<xs:annotation>
					<xs:documentation>method=Description;method_base_class=CVmDevice;</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="UseExternalRasterizer" type="xs:boolean" minOccurs="0">
				<xs:annotation>
					<xs:documentation>method=RastEnabled;Need for Windows OS real printer that does not support PS printing</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
	</xs:complexType>
	<xs:element name="ParallelsVirtualMachine">
		<xs:annotation>
			<xs:documentation>class=CVmConfiguration;</xs:documentation>
			<xs:documentation source="ConfigDirectory">header_fragment:
    // Get Configuration directory name
    QString getConfigDirectory() const;
</xs:documentation>
			<xs:documentation source="ConfigDirectory_impl">unit_fragment:
QString CVmConfiguration::getConfigDirectory() const
{
    QString strVmDir = this-&gt;getOutFileName();
    strVmDir = QDir::fromNativeSeparators( strVmDir );
    strVmDir = QFileInfo(strVmDir).dir().absolutePath();
    return strVmDir;
}
</xs:documentation>
			<xs:documentation source="makeAppVersion">header_fragment:
    static QString makeAppVersion();
</xs:documentation>
			<xs:documentation source="makeAppVersion_impl">unit_fragment:
#include "Build/Current.ver"
QString CVmConfiguration::makeAppVersion()
{
	return QString( "%1" ).arg( VER_FULL_BUILD_NUMBER_STR );
}
</xs:documentation>
			<xs:documentation source="StringToElement">post_class_info:
template &lt;class T&gt; bool StringToElement(T Element, const QString&amp; source_string)
{
	QDomDocument xmlSourceDoc;
	// Parse error string
	QString strErrMsg;
	// Parse error line
	int iErrLine;
	// Parse error column
	int iErrCol;

	bool parse_rc = xmlSourceDoc.setContent( source_string,
		true, &amp;strErrMsg, &amp;iErrLine, &amp;iErrCol );
	if( !parse_rc )
	{
		return false;
	}

	// setup root element
	QDomElement xmlVmConfigRoot = xmlSourceDoc.documentElement();
	QDomElement xmlHddChild = xmlVmConfigRoot.firstChild().toElement();

	int read_rc = Element-&gt;readXml( &amp;xmlHddChild );
	if ( IS_OPERATION_SUCCEEDED( read_rc ) )
	{
		Element-&gt;setItemId( xmlHddChild.attribute("id", "-1").toInt() );
		return true;
	}

	read_rc = Element-&gt;readXml( &amp;xmlVmConfigRoot );
	if ( ! IS_OPERATION_SUCCEEDED( read_rc ) )
	{
		return false;
	}
	Element-&gt;setItemId( xmlVmConfigRoot.attribute("id", "-1").toInt() );

	return true;
}
</xs:documentation>
			<xs:documentation source="ElementToString">post_class_info:
template &lt;class T&gt; QString ElementToString(T Element, const QString&amp; tagName)
{
	QDomDocument xmlDummyParentDoc;
	QDomElement xmlVmConfigRoot;
	QDomNode xmlXmlVersionNode;

	xmlXmlVersionNode = xmlDummyParentDoc.createProcessingInstruction(
		XML_DOC_VERSION_TAG, XML_DOC_VERSION_DATA );
	xmlDummyParentDoc.insertBefore( xmlXmlVersionNode, xmlDummyParentDoc.firstChild() );

	// create root element
	xmlVmConfigRoot = xmlDummyParentDoc.createElement( tagName );
	xmlDummyParentDoc.appendChild( xmlVmConfigRoot );
	// append given element
	QDomElement root_element = Element-&gt;getXml( &amp;xmlDummyParentDoc );
	root_element.setAttribute("id", Element-&gt;getItemId());
	xmlVmConfigRoot.appendChild(root_element);

	QString strOutput;
	QTextStream out( &amp;strOutput );

	xmlDummyParentDoc.save( out, 3 );
	out.flush();

	return strOutput;
}
</xs:documentation>
			<xs:documentation source="setAbsolutePath">header_fragment:	void setAbsolutePath();
</xs:documentation>
			<xs:documentation source="setAbsolutePath_impl">unit_fragment:
void CVmConfiguration::setAbsolutePath()
{
	CVmHardware* pHwList = getVmHardwareList();
	if (pHwList)
		pHwList-&gt;RevertDevicesPathToAbsolute(getConfigDirectory());
}
</xs:documentation>
			<xs:documentation source="setRelativePath">header_fragment:
	void setRelativePath();
</xs:documentation>
			<xs:documentation source="setRelativePath_impl">unit_fragment:
void CVmConfiguration::setRelativePath()
{
	CVmHardware* pHwList = getVmHardwareList();
	if (pHwList)
		pHwList-&gt;SetDevicesPathToRelative( getConfigDirectory(), getExternalConfigInfo()-&gt;getType() != PEVT_NATIVE_VM );
}
</xs:documentation>
			<xs:documentation source="loadFromFile">header_fragment:    int loadFromFile(QFile* config_file,bool BNeedLoadAbsolutePath = true);
</xs:documentation>
			<xs:documentation source="loadFromFile_impl">unit_fragment:
int CVmConfiguration::loadFromFile(QFile* config_file, bool BNeedLoadRelativePath)
{
    if ( CBaseNode::loadFromFile(config_file) )
    {
        return PRL_ERR_PARSE_VM_CONFIG;
    }

    if (BNeedLoadRelativePath)
		setAbsolutePath();
    return 0;
}
</xs:documentation>
			<xs:documentation source="saveToFile">header_fragment:
    int saveToFile(QFile* config_file, bool do_replace = true, bool BNeedToSaveRelativePath = true);
    int saveToFile(QString config_file, bool do_replace = true, bool BNeedToSaveRelativePath = true);
</xs:documentation>
			<xs:documentation source="saveToFile_impl">unit_fragment:
int CVmConfiguration::saveToFile(QFile* config_file, bool do_replace, bool BNeedToSaveRelativePath)
{

	m_qsFileName = config_file-&gt;fileName();

    if (BNeedToSaveRelativePath)
		setRelativePath();

    int res = CBaseNode::saveToFile(config_file, do_replace, BNeedToSaveRelativePath);

    if (BNeedToSaveRelativePath)
		setAbsolutePath();
    return res;
}

int CVmConfiguration::saveToFile(QString config_file, bool do_replace, bool BNeedToSaveRelativePath)
{
    QFile outFile( config_file );
    return this-&gt;saveToFile( &amp;outFile, do_replace,BNeedToSaveRelativePath);;
}
</xs:documentation>
			<xs:documentation source="getXml">header_fragment:
    QDomDocument getXml() { return CBaseNode::getXml(); }</xs:documentation>
			<xs:documentation source="readXml">header_fragment:
    int readXml(QDomDocument* Document);
</xs:documentation>
			<xs:documentation source="readXml_impl">unit_fragment:
int CVmConfiguration::readXml(QDomDocument* Document)
{
    QDomElement element = Document->firstChildElement();
    return readXml(&amp;element);
}
</xs:documentation>
			<xs:documentation source="Init constructor">header_fragment:
    CVmConfiguration(QString s) { InitLists(); fromString(s); }</xs:documentation>
			<xs:documentation source="hasEnabledGenericPciDevices">header_fragment:
    bool hasEnabledGenericPciDevices() const;
</xs:documentation>
			<xs:documentation source="hasEnabledGenericPciDevices_impl">unit_fragment:
bool CVmConfiguration::hasEnabledGenericPciDevices() const
{
	CVmHardware* pHwList = getVmHardwareList();
	foreach( CVmGenericPciDevice* pVmDev, pHwList-&gt;m_lstGenericPciDevices )
	{
		if( pVmDev-&gt;getEnabled() != PVE::DeviceEnabled )
			continue;
		return true;
	}

	foreach( CVmPciVideoAdapter* pVmDev, pHwList-&gt;m_lstPciVideoAdapters )
	{
		if( pVmDev-&gt;getEnabled() != PVE::DeviceEnabled )
			continue;
		return true;
	}

	foreach( CVmGenericNetworkAdapter* pVmDev, pHwList-&gt;m_lstNetworkAdapters )
	{
		if( pVmDev-&gt;getEnabled() != PVE::DeviceEnabled )
			continue;

		if( (PRL_VM_DEV_EMULATION_TYPE )pVmDev-&gt;getEmulatedType() != PDT_USE_DIRECT_ASSIGN )
			continue;

		return true;
	}

	return false;
}
</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:sequence>
				<xs:element name="AppVersion" type="xs:string">
					<xs:annotation>
						<xs:documentation>method=AppVersion;default=makeAppVersion();attribute=appVersion;</xs:documentation>
					</xs:annotation>
				</xs:element>
				<xs:element name="ValidRc" type="xs:integer" minOccurs="0"/>
				<xs:element name="VmType" type="xs:integer" default="PVT_VM" minOccurs="0">
					<xs:annotation>
						<xs:documentation>type=PRL_VM_TYPE;no_save=on;</xs:documentation>
					</xs:annotation>
				</xs:element>
				<xs:element name="Identification" type="IdentificationType">
					<xs:annotation>
						<xs:documentation>method=VmIdentification;single_fixed=on;</xs:documentation>
					</xs:annotation>
				</xs:element>
				<xs:element name="Security">
					<xs:annotation>
						<xs:documentation>class=CVmSecurity;method=VmSecurity;single_fixed=on;</xs:documentation>
					</xs:annotation>
					<xs:complexType>
						<xs:sequence>
							<xs:element name="AccessControlList">
								<xs:annotation>
									<xs:documentation>single_fixed=on;</xs:documentation>
								</xs:annotation>
								<xs:complexType>
									<xs:sequence>
										<xs:element name="AccessControl" type="xs:integer" default="QList&lt;PRL_ALLOWED_VM_COMMAND&gt;()" minOccurs="0" maxOccurs="unbounded">
											<xs:annotation>
												<xs:documentation>type=PRL_ALLOWED_VM_COMMAND;</xs:documentation>
											</xs:annotation>
										</xs:element>
									</xs:sequence>
								</xs:complexType>
							</xs:element>
							<xs:element name="LockedOperationsList">
								<xs:annotation>
									<xs:documentation>class=CVmLockedOperationsList;single_fixed=on;</xs:documentation>
								</xs:annotation>
								<xs:complexType>
									<xs:sequence>
										<xs:element name="LockedOperation" type="xs:integer" default="QList&lt;PRL_ALLOWED_VM_COMMAND&gt;()" minOccurs="0" maxOccurs="unbounded">
											<xs:annotation>
												<xs:documentation>type=PRL_ALLOWED_VM_COMMAND;method=LockedOperations;</xs:documentation>
											</xs:annotation>
										</xs:element>
									</xs:sequence>
								</xs:complexType>
							</xs:element>
							<xs:element name="Owner" type="xs:string" minOccurs="0"/>
							<xs:element name="IsOwner" type="xs:boolean" minOccurs="0">
								<xs:annotation>
									<xs:documentation>method=OwnerPresent;</xs:documentation>
								</xs:annotation>
							</xs:element>
							<xs:element name="AccessForOthers" type="xs:integer" default="PAO_VM_NOT_SHARED" minOccurs="0">
								<xs:annotation>
									<xs:documentation>type=PRL_VM_ACCESS_FOR_OTHERS;</xs:documentation>
								</xs:annotation>
							</xs:element>
							<xs:element name="LockedSign" type="xs:boolean" default="false" minOccurs="0"/>
							<xs:element name="ParentalControlEnabled" type="xs:boolean" default="true" minOccurs="0">
								<xs:annotation>
									<xs:documentation/>
									<xs:documentation source="patch on">patch:</xs:documentation>
								</xs:annotation>
							</xs:element>
						</xs:sequence>
					</xs:complexType>
				</xs:element>
				<xs:element name="Settings" type="SettingsType">
					<xs:annotation>
						<xs:documentation>method=VmSettings;single_fixed=on;</xs:documentation>
					</xs:annotation>
				</xs:element>
				<xs:element name="CtSettings">
					<xs:annotation>
						<xs:documentation>class=CCtSettings;single_fixed=on;no_save=on</xs:documentation>
						<xs:documentation>include="CCtResource.h";</xs:documentation>
						<xs:documentation source="addResource">header_fragment:
	void addResource(CCtResource *pRes);
	CCtResource *getResource(PRL_CT_RESOURCE id);
</xs:documentation>
						<xs:documentation source="addResource impl">unit_fragment:
void CCtSettings::addResource(CCtResource *pRes)
{
	foreach(CCtResource *p, m_lstCtResource)
	{
		if (p-&gt;getResourceId() == pRes-&gt;getResourceId())
		{
			p-&gt;setBarrier(pRes-&gt;getBarrier());
			p-&gt;setLimit(pRes-&gt;getLimit());
			delete pRes;
			return;
		}
	}
	m_lstCtResource.append(pRes);
}

CCtResource *CCtSettings::getResource(PRL_CT_RESOURCE id)
{
	foreach(CCtResource *p, m_lstCtResource)
	{
		if (p-&gt;getResourceId() == id)
			return p;
	}
	return NULL;
}
</xs:documentation>
					</xs:annotation>
					<xs:complexType>
						<xs:sequence>
							<xs:element name="ConfigSample" type="xs:string" minOccurs="0"/>
							<xs:element name="OsTemplate" type="xs:string" minOccurs="0"/>
							<xs:element name="AppTemplate" type="xs:string" minOccurs="0" maxOccurs="unbounded"/>
							<xs:element name="MountPath" type="xs:string" minOccurs="0"/>
							<xs:element name="Layout" type="xs:integer" default="0" minOccurs="0"/>
							<xs:element name="CapabilitiesMask" type="xs:unsignedLong" minOccurs="0"/>
							<xs:element name="NetfilterMode" type="xs:integer" minOccurs="0">
								<xs:annotation>
									<xs:documentation>type=PRL_NETFILTER_MODE;</xs:documentation>
								</xs:annotation>
							</xs:element>
							<xs:element name="FeaturesOnMask" type="xs:unsignedLong" minOccurs="0"/>
							<xs:element name="FeaturesOffMask" type="xs:unsignedLong" minOccurs="0"/>
							<xs:element name="CtResource" type="CtResourceType" minOccurs="0" maxOccurs="unbounded">
								<xs:annotation>
									<xs:documentation>method=CtResources;</xs:documentation>
								</xs:annotation>
							</xs:element>
						</xs:sequence>
					</xs:complexType>
				</xs:element>
				<xs:element name="Hardware" type="HardwareType">
					<xs:annotation>
						<xs:documentation>method=VmHardwareList;single_fixed=on;</xs:documentation>
					</xs:annotation>
				</xs:element>
				<xs:element name="VirtualAppliance" type="ParallelsVirtualApplianceType" minOccurs="0">
					<xs:annotation>
						<xs:documentation>method=VaConfig;</xs:documentation>
					</xs:annotation>
				</xs:element>
				<xs:element name="InstalledSoftware" type="xs:integer" minOccurs="0"/>
				<xs:element name="ExternalConfigInfo">
					<xs:annotation>
						<xs:documentation>class=CVmExternalConfigInfo;single_fixed=on;</xs:documentation>
					</xs:annotation>
					<xs:complexType>
						<xs:sequence>
							<xs:element name="Type" type="xs:integer" default="PEVT_NATIVE_VM" minOccurs="0">
								<xs:annotation>
									<xs:documentation>type=PRL_EXTERNAL_VM_TYPE;</xs:documentation>
								</xs:annotation>
							</xs:element>
							<xs:element name="ConfigPath" type="xs:string" minOccurs="0"/>
							<xs:element name="CheckSum" type="xs:string" minOccurs="0"/>
						</xs:sequence>
					</xs:complexType>
				</xs:element>
			</xs:sequence>
			<xs:attribute name="schemaVersion" type="xs:decimal" use="required"/>
		</xs:complexType>
	</xs:element>
	<xs:complexType name="PartitionType">
		<xs:annotation>
			<xs:documentation>class=CVmHddPartition;</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="SystemName" type="xs:string"/>
		</xs:sequence>
	</xs:complexType>
	<xs:element name="Passthrough" type="xs:integer"/>
	<xs:element name="Path" type="xs:string"/>
	<xs:complexType name="PciVideoAdapterType">
		<xs:annotation>
			<xs:documentation>class=CVmPciVideoAdapter;base_class=CVmGenericPciDevice;object_id=on;</xs:documentation>
			<xs:documentation source="getDeviceType">header_fragment:
    virtual PRL_DEVICE_TYPE getDeviceType() const { return PDE_PCI_VIDEO_ADAPTER; }
</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="Index" type="xs:integer">
				<xs:annotation>
					<xs:documentation>attribute=index;method_base_class=CVmDevice;</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Enabled" type="xs:integer">
				<xs:annotation>
					<xs:documentation>method_base_class=CVmDevice;type=PVE::DeviceEnabledState;</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Connected" type="xs:integer">
				<xs:annotation>
					<xs:documentation>method_base_class=CVmDevice;type=PVE::DeviceConnectedState;</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="EmulatedType" type="xs:integer">
				<xs:annotation>
					<xs:documentation>method_base_class=CVmDevice;default=PDT_USE_REAL_DEVICE;</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="SystemName" type="xs:string">
				<xs:annotation>
					<xs:documentation>method_base_class=CVmDevice;</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="UserFriendlyName" type="xs:string">
				<xs:annotation>
					<xs:documentation>method_base_class=CVmDevice;</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Remote" type="xs:boolean">
				<xs:annotation>
					<xs:documentation>method_base_class=CVmDevice;</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Type" type="xs:integer" minOccurs="0">
				<xs:annotation>
					<xs:documentation>method_base_class=CVmGenericPciDevice;type=PRL_GENERIC_PCI_DEVICE_CLASS;default=PGD_PCI_DISPLAY;</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="DeviceDescription" type="xs:string" minOccurs="0">
				<xs:annotation>
					<xs:documentation>method=Description;method_base_class=CVmDevice;</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
	</xs:complexType>
	<xs:complexType name="PrinterType">
		<xs:annotation>
			<xs:documentation>class=CVmParallelPort;base_class=CVmPort;object_id=on;</xs:documentation>
			<xs:documentation source="Comparision operator">header_fragment:
    virtual bool operator==( const CVmParallelPort&amp; cVmParallelPort );
</xs:documentation>
			<xs:documentation source="Comparision operator_impl">unit_fragment:
bool CVmParallelPort::operator==( const CVmParallelPort&amp; cVmParallelPort )
{
	return CVmPort::operator ==(cVmParallelPort);
}
</xs:documentation>
			<xs:documentation source="getDeviceType">header_fragment:
    virtual PRL_DEVICE_TYPE getDeviceType() const { return PDE_PARALLEL_PORT; }
</xs:documentation>
			<xs:documentation source="getEmulatedType">header_fragment:
    PVE::ParallelPortEmulatedType getEmulatedType() const { return (PVE::ParallelPortEmulatedType )CVmDevice::getEmulatedType(); }
</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="Index" type="xs:integer">
				<xs:annotation>
					<xs:documentation>attribute=index;method_base_class=CVmDevice;</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Enabled" type="xs:integer">
				<xs:annotation>
					<xs:documentation>method_base_class=CVmDevice;type=PVE::DeviceEnabledState;</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Connected" type="xs:integer">
				<xs:annotation>
					<xs:documentation>method_base_class=CVmDevice;type=PVE::DeviceConnectedState;</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="EmulatedType" type="xs:integer">
				<xs:annotation>
					<xs:documentation>method_base_class=CVmDevice;default=PVE::RealParallelPort;</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="SystemName" type="xs:string">
				<xs:annotation>
					<xs:documentation>method_base_class=CVmDevice;</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="UserFriendlyName" type="xs:string">
				<xs:annotation>
					<xs:documentation>method_base_class=CVmDevice;</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Remote" type="xs:boolean">
				<xs:annotation>
					<xs:documentation>method_base_class=CVmDevice;</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="PrinterInterfaceType" type="xs:integer" default="PRN_USB_DEVICE" minOccurs="0">
				<xs:annotation>
					<xs:documentation>type=PRL_PRINTER_INTERFACE_TYPE;</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="DeviceDescription" type="xs:string" minOccurs="0">
				<xs:annotation>
					<xs:documentation>method=Description;method_base_class=CVmDevice;</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="UseExternalRasterizer" type="xs:boolean" minOccurs="0">
				<xs:annotation>
					<xs:documentation>method=RastEnabled; Need for Windows OS real printer that does not support PS printing</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
	</xs:complexType>
	<xs:element name="RAM" type="xs:integer" default="XML_DEFAULT_RAM_SIZE">
		<xs:annotation>
			<xs:documentation>method=RamSize;</xs:documentation>
		</xs:annotation>
	</xs:element>
	<xs:element name="ReadOnly" type="xs:boolean"/>
	<xs:element name="RelocateTaskBar" type="xs:boolean" default="XML_DEFAULT_CHRN_RELOCATETASKBAR">
		<xs:annotation>
			<xs:documentation/>
			<xs:documentation source="patch on">patch:</xs:documentation>
		</xs:annotation>
	</xs:element>
	<xs:complexType name="RuntimeType">
		<xs:annotation>
			<xs:documentation>class=CVmRunTimeOptions;</xs:documentation>
			<xs:documentation source="CustomInit">header_fragment:
	virtual void CustomInit();
</xs:documentation>
			<xs:documentation source="CustomInit_impl">unit_fragment:
void CVmRunTimeOptions::CustomInit()
{
	getVmFullScreen()-&gt;setCornerAction(PWC_TOP_LEFT_CORNER, PCA_WINDOWED);
}
</xs:documentation>
			<xs:documentation source="getDockIcon">header_fragment:
    PRL_DOCK_ICON_TYPE getDockIcon() const { return getDockIconType(); }
</xs:documentation>
			<xs:documentation source="getUndoDisksModeEx">header_fragment:
    PRL_UNDO_DISKS_MODE getUndoDisksModeEx() const;</xs:documentation>
			<xs:documentation source="getUndoDisksModeEx_impl">unit_fragment:
PRL_UNDO_DISKS_MODE CVmRunTimeOptions::getUndoDisksModeEx() const
{
    return isSafeMode() ? PUD_PROMPT_BEHAVIOUR : getUndoDisksMode();
}</xs:documentation>
			<xs:documentation source="isOptimizeForVM">header_fragment:
	bool isOptimizeForVM() const;</xs:documentation>
			<xs:documentation source="isOptimizeForVM_impl">unit_fragment:
bool CVmRunTimeOptions::isOptimizeForVM() const
{
	// Right now DiskCachePolicy config option represents the whole class of
	// optimizations for VM (historical reasons)
	return getDiskCachePolicy() == PVE::DiskCacheWritebackEnabled;
}
</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element ref="ForegroundPriority"/>
			<xs:element ref="BackgroundPriority"/>
			<xs:element name="IoPriority" type="xs:integer" default="4" minOccurs="0"/>
			<xs:element name="IoLimit" minOccurs="0">
				<xs:annotation>
					<xs:documentation>class=CVmIoLimit</xs:documentation>
					<xs:documentation source="Comparision operator">header_fragment:
	virtual bool operator==( const CVmIoLimit&amp; cVmIoLimit );
</xs:documentation>
					<xs:documentation source="Comparision operator_impl">unit_fragment:
bool CVmIoLimit::operator==( const CVmIoLimit&amp; cVmIoLimit )
{
	if ((getIoLimitType() == cVmIoLimit.getIoLimitType()) &amp;&amp;
		(getIoLimitValue() == cVmIoLimit.getIoLimitValue()))
		return true;
	return false;
}
</xs:documentation>
					<xs:documentation source="Constructor operator">header_fragment:
	CVmIoLimit(const PRL_IOLIMIT_TYPE&amp;, const PRL_UINT32&amp;);
</xs:documentation>
					<xs:documentation source="Costructor operator_impl">unit_fragment:
CVmIoLimit::CVmIoLimit(const PRL_IOLIMIT_TYPE&amp; type, const PRL_UINT32&amp; value)
{
	setIoLimitType(type);
	setIoLimitValue(value);
}
</xs:documentation>
				</xs:annotation>
				<xs:complexType>
					<xs:sequence>
						<xs:element name="IoLimitType" type="xs:integer" default="PRL_IOLIMIT_BS">
							<xs:annotation>
								<xs:documentation>type=PRL_IOLIMIT_TYPE;</xs:documentation>
							</xs:annotation>
						</xs:element>
						<xs:element name="IoLimitValue" type="xs:integer" default="0"/>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<xs:element name="IopsLimit" type="xs:integer" default="0" minOccurs="0"/>
			<xs:element ref="DiskCachePolicy"/>
			<xs:element ref="CloseAppOnShutdown"/>
			<xs:element name="ActionOnStop" type="xs:integer" default="PAS_KEEP_VM_WINDOW_OPEN" minOccurs="0">
				<xs:annotation>
					<xs:documentation>type=PRL_VM_ACTION_ON_STOP;</xs:documentation>
					<xs:documentation source="Initialize ActionOnStop from CloseAppOnShutdown">post_read_fragment:
	if ( RootElement->firstChildElement( "ActionOnStop" ).isNull() )
	{
		// pick a value from deprecated isCloseAppOnShutdown() element
		PRL_VM_ACTION_ON_STOP actionOnStop = isCloseAppOnShutdown() ? PAS_CLOSE_VM_WINDOW : PAS_KEEP_VM_WINDOW_OPEN;
		setActionOnStop(actionOnStop);
	}
</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="DockIcon" type="xs:integer" default="PIT_DOCK_ICON_SYSTEM">
				<xs:annotation>
					<xs:documentation>method=DockIconType;type=PRL_DOCK_ICON_TYPE;</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="OsResolutionInFullScreen" type="xs:boolean"/>
			<xs:element name="FullScreen" type="FullScreenType">
				<xs:annotation>
					<xs:documentation>method=VmFullScreen;single_fixed=on;</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="UndoDisks" type="xs:integer" default="PUD_DISABLE_UNDO_DISKS">
				<xs:annotation>
					<xs:documentation>method=UndoDisksMode;type=PRL_UNDO_DISKS_MODE;</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="SafeMode" type="xs:boolean" minOccurs="0"/>
			<xs:element ref="SystemFlags"/>
			<xs:element name="DisableAPIC" type="xs:boolean" default="false" minOccurs="0"/>
			<xs:element name="OptimizePowerConsumptionMode" type="xs:integer" default="PVE::OptimizePerformance" minOccurs="0">
				<xs:annotation>
					<xs:documentation>method=OptimizePowerConsumptionMode;type=PVE::OptimizePowerConsumptionMode;</xs:documentation>
					<xs:documentation source="patch on">patch:</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="ShowBatteryStatus" type="xs:boolean" default="true" minOccurs="0"/>
			<xs:element name="Enabled" type="xs:boolean" minOccurs="0"/>
			<xs:element name="EnableAdaptiveHypervisor" type="xs:boolean" minOccurs="0"/>
			<xs:element name="UseSMBiosData" type="xs:boolean" default="false" minOccurs="0"/>
			<xs:element name="DisableSpeaker" type="xs:boolean" default="true" minOccurs="0"/>
			<xs:element name="HideBiosOnStartEnabled" type="xs:boolean" minOccurs="0"/>
			<xs:element name="UseDefaultAnswers" type="xs:boolean" default="false" minOccurs="0"/>
			<xs:element name="CompactHddMask" type="xs:integer" minOccurs="0"/>
			<xs:element name="CompactMode" type="xs:boolean" minOccurs="0"/>
			<xs:element name="DisableWin7Logo" type="xs:boolean" default="true" minOccurs="0"/>
			<xs:element name="OptimizeModifiers" type="xs:integer" default="POD_STANDARD" minOccurs="0">
				<xs:annotation>
					<xs:documentation>type=PRL_OPTIMIZE_MODIFIERS_MODE;</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="StickyMouse" type="xs:boolean" default="false" minOccurs="0">
				<xs:annotation>
					<xs:documentation/>
					<xs:documentation source="patch on">patch:</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="PauseOnDeactivation" type="xs:boolean" default="false" minOccurs="0"/>
			<xs:element name="FEATURES_MASK" type="xs:integer" minOccurs="0"/>
			<xs:element name="EXT_FEATURES_MASK" type="xs:integer" minOccurs="0"/>
			<xs:element name="EXT_80000001_ECX_MASK" type="xs:integer" minOccurs="0"/>
			<xs:element name="EXT_80000001_EDX_MASK" type="xs:integer" minOccurs="0"/>
			<xs:element name="EXT_80000007_EDX_MASK" type="xs:integer" minOccurs="0"/>
			<xs:element name="EXT_80000008_EAX" type="xs:integer" minOccurs="0"/>
			<xs:element name="EXT_00000007_EBX_MASK" type="xs:integer" minOccurs="0"/>
			<xs:element name="EXT_0000000D_EAX_MASK" type="xs:integer" minOccurs="0"/>
			<xs:element name="CpuFeaturesMaskValid" type="xs:boolean" default="false" minOccurs="0"/>
			<xs:element name="InternalVmInfo">
				<xs:annotation>
					<xs:documentation>single_fixed=on;no_save=on</xs:documentation>
				</xs:annotation>
				<xs:complexType>
					<xs:sequence>
						<xs:element name="ParallelsEvent">
							<xs:annotation>
								<xs:documentation>single_fixed=on;class=CVmEvent;extern=XmlModel/Messaging/CVmEvent.h;list=VmInfo</xs:documentation>
							</xs:annotation>
							<xs:complexType>
								<xs:sequence>
									<xs:element name="external"/>
								</xs:sequence>
							</xs:complexType>
						</xs:element>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<xs:element name="UnattendedInstallLocale" type="xs:string" minOccurs="0"/>
			<xs:element name="UnattendedInstallEdition" type="xs:string" minOccurs="0"/>
			<xs:element name="HostRetinaEnabled" type="xs:boolean" minOccurs="0"/>
		</xs:sequence>
	</xs:complexType>
	<xs:element name="SchedBasis" type="xs:integer" default="PVE::VmNoSchedule">
		<xs:annotation>
			<xs:documentation>method=ScheduleBasis;type=PVE::VmScheduleBasis;</xs:documentation>
		</xs:annotation>
	</xs:element>
	<xs:element name="SchedDay" type="xs:integer">
		<xs:annotation>
			<xs:documentation>method=Day;</xs:documentation>
		</xs:annotation>
	</xs:element>
	<xs:element name="SchedDayOfMonth" type="xs:integer">
		<xs:annotation>
			<xs:documentation>method=DayOfMonth;</xs:documentation>
		</xs:annotation>
	</xs:element>
	<xs:element name="SchedDayOfWeek" type="xs:integer">
		<xs:annotation>
			<xs:documentation>method=DayOfWeek;</xs:documentation>
		</xs:annotation>
	</xs:element>
	<xs:element name="SchedGranularity" type="xs:integer">
		<xs:annotation>
			<xs:documentation>method=ScheduleGranularity;</xs:documentation>
		</xs:annotation>
	</xs:element>
	<xs:element name="SchedMonth" type="xs:integer">
		<xs:annotation>
			<xs:documentation>method=Month;</xs:documentation>
		</xs:annotation>
	</xs:element>
	<xs:element name="SchedStartDate" type="xs:date">
		<xs:annotation>
			<xs:documentation>method=StartDate;default=QDate::fromString( XML_DEFAULT_DATE, XML_DEFAULT_DATE_FORMAT );</xs:documentation>
		</xs:annotation>
	</xs:element>
	<xs:element name="SchedStartTime" type="xs:time">
		<xs:annotation>
			<xs:documentation>method=StartTime;default=QTime::fromString( XML_DEFAULT_TIME, XML_DEFAULT_TIME_FORMAT);</xs:documentation>
		</xs:annotation>
	</xs:element>
	<xs:element name="SchedStopDate" type="xs:date">
		<xs:annotation>
			<xs:documentation>method=StopDate;default=QDate::fromString(XML_DEFAULT_DATE, XML_DEFAULT_DATE_FORMAT);</xs:documentation>
		</xs:annotation>
	</xs:element>
	<xs:element name="SchedStopTime" type="xs:time">
		<xs:annotation>
			<xs:documentation>method=StopTime;default=QTime::fromString(XML_DEFAULT_TIME, XML_DEFAULT_TIME_FORMAT);</xs:documentation>
		</xs:annotation>
	</xs:element>
	<xs:element name="SchedWeek" type="xs:integer">
		<xs:annotation>
			<xs:documentation>method=Week;</xs:documentation>
		</xs:annotation>
	</xs:element>
	<xs:complexType name="ScheduleType">
		<xs:annotation>
			<xs:documentation>class=CVmScheduleOptions;</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element ref="SchedBasis"/>
			<xs:element ref="SchedGranularity"/>
			<xs:element ref="SchedDayOfWeek"/>
			<xs:element ref="SchedDayOfMonth"/>
			<xs:element ref="SchedDay"/>
			<xs:element ref="SchedWeek"/>
			<xs:element ref="SchedMonth"/>
			<xs:element ref="SchedStartDate"/>
			<xs:element ref="SchedStartTime"/>
			<xs:element ref="SchedStopDate"/>
			<xs:element ref="SchedStopTime"/>
		</xs:sequence>
	</xs:complexType>
	<xs:complexType name="ScreenResolutionType">
		<xs:annotation>
			<xs:documentation>class=CVmScreenResolution;</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="Enabled" type="xs:boolean" default="true"/>
			<xs:element name="Width" type="xs:integer" default="XML_DEFAULT_SCREEN_WIDTH"/>
			<xs:element name="Height" type="xs:integer" default="XML_DEFAULT_SCREEN_HEIGHT"/>
		</xs:sequence>
	</xs:complexType>
	<xs:complexType name="ScreenResolutionsType">
		<xs:annotation>
			<xs:documentation>class=CVmScreenResolutions;</xs:documentation>
			<xs:documentation source="addScreenResolution">header_fragment:
    // Add screen resolution to the list
    void addScreenResolution(CVmScreenResolution* item);
</xs:documentation>
			<xs:documentation source="addScreenResolution_impl">unit_fragment:
void CVmScreenResolutions::addScreenResolution(CVmScreenResolution* item)
{
    m_lstScreenResolutions.append( item );
}
</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="Enabled" type="xs:boolean"/>
			<xs:element name="ScreenResolution" type="ScreenResolutionType" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>list=ScreenResolutions;</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
	</xs:complexType>
	<xs:complexType name="SerialType">
		<xs:annotation>
			<xs:documentation>class=CVmSerialPort;base_class=CVmPort;object_id=on;</xs:documentation>
			<xs:documentation source="Comparision operator">header_fragment:
    virtual bool operator==( const CVmSerialPort&amp; cVmSerialPort);
</xs:documentation>
			<xs:documentation source="Comparision operator_impl">unit_fragment:
bool CVmSerialPort::operator==( const CVmSerialPort&amp; cVmSerialPort)
{
	if (CVmPort::operator ==(cVmSerialPort))
	{
		if (getSocketMode() == cVmSerialPort.getSocketMode())
			return true;
	}
	
	return false;
}
</xs:documentation>
			<xs:documentation source="getDeviceType">header_fragment:
    virtual PRL_DEVICE_TYPE getDeviceType() const { return PDE_SERIAL_PORT; }
</xs:documentation>
			<xs:documentation source="getEmulatedType">header_fragment:
    PVE::SerialPortEmulatedType getEmulatedType() const { return (PVE::SerialPortEmulatedType )CVmDevice::getEmulatedType(); }
</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="Index" type="xs:integer">
				<xs:annotation>
					<xs:documentation>attribute=index;method_base_class=CVmDevice;</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Enabled" type="xs:integer">
				<xs:annotation>
					<xs:documentation>method_base_class=CVmDevice;type=PVE::DeviceEnabledState;</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Connected" type="xs:integer">
				<xs:annotation>
					<xs:documentation>method_base_class=CVmDevice;type=PVE::DeviceConnectedState;</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="EmulatedType" type="xs:integer">
				<xs:annotation>
					<xs:documentation>method_base_class=CVmDevice;default=PVE::RealSerialPort;</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="SystemName" type="xs:string">
				<xs:annotation>
					<xs:documentation>method_base_class=CVmDevice;</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="UserFriendlyName" type="xs:string">
				<xs:annotation>
					<xs:documentation>method_base_class=CVmDevice;</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Remote" type="xs:boolean">
				<xs:annotation>
					<xs:documentation>method_base_class=CVmDevice;</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="SocketMode" type="xs:integer" default="PSP_SERIAL_SOCKET_SERVER" minOccurs="0">
				<xs:annotation>
					<xs:documentation>type=PRL_SERIAL_PORT_SOCKET_OPERATION_MODE;</xs:documentation>
					<xs:documentation source="Tag condition">condition:(PVE::SerialPortEmulatedType )getEmulatedType() == PVE::SerialSocket</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="OperateAtRealSpeed" type="xs:boolean" minOccurs="0"/>
			<xs:element name="DeviceDescription" type="xs:string" minOccurs="0">
				<xs:annotation>
					<xs:documentation>method=Description;method_base_class=CVmDevice;</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
	</xs:complexType>
	<xs:element name="ServerHost" type="xs:string"/>
	<xs:element name="ServerUuid" type="xs:string">
		<xs:annotation>
			<xs:documentation>default=Uuid::createUuid().toString();</xs:documentation>
		</xs:annotation>
	</xs:element>
	<xs:element name="LastServerUuid" type="xs:string"/>
	<xs:complexType name="SettingsType">
		<xs:annotation>
			<xs:documentation>class=CVmSettings;</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="General" type="GeneralType" block="restriction">
				<xs:annotation>
					<xs:documentation>method=VmCommonOptions;single_fixed=on;</xs:documentation>
					<xs:documentation source="Comparision operator">header_fragment:
    virtual bool operator==( const CVmCommonOptions&amp; cVmCommonOptions);
</xs:documentation>
					<xs:documentation source="Comparision operator_impl">unit_fragment:
bool CVmCommonOptions::operator==( const CVmCommonOptions&amp; cVmCommonOptions)
{
	if (
		(getOsType() == cVmCommonOptions.getOsType()) &amp;&amp;
		(getOsVersion() == cVmCommonOptions.getOsVersion()) &amp;&amp;
		(getIcon() == cVmCommonOptions.getIcon()) &amp;&amp;
		(getVmDescription() == cVmCommonOptions.getVmDescription())
		)
			return true;
	return false;
}
</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Startup" type="StartupType">
				<xs:annotation>
					<xs:documentation>method=VmStartupOptions;single_fixed=on;</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Shutdown">
				<xs:annotation>
					<xs:documentation>single_fixed=on;</xs:documentation>
				</xs:annotation>
				<xs:complexType>
					<xs:sequence>
						<xs:element name="AutoStop" type="xs:integer" default="PAO_VM_SUSPEND">
							<xs:annotation>
								<xs:documentation>type=PRL_VM_AUTOSTOP_OPTION;</xs:documentation>
							</xs:annotation>
						</xs:element>
						<xs:element name="OnVmWindowClose" type="xs:integer" default="PWC_VM_ASK_USER" minOccurs="0">
							<xs:annotation>
								<xs:documentation>type=PRL_VM_ACTION_ON_WINDOW_CLOSE;</xs:documentation>
							</xs:annotation>
						</xs:element>
						<xs:element name="WindowOnShutdown" type="xs:int" minOccurs="0"/>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<xs:element name="ClusterOptions" block="restriction">
				<xs:annotation>
					<xs:documentation>single_fixed=on;</xs:documentation>
				</xs:annotation>
				<xs:complexType>
					<xs:sequence>
						<xs:element name="Running" type="xs:boolean" default="false" minOccurs="0"/>
						<xs:element name="ServiceName" type="xs:string" minOccurs="0"/>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<xs:element name="Runtime" type="RuntimeType">
				<xs:annotation>
					<xs:documentation>method=VmRuntimeOptions;single_fixed=on;</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Schedule" type="ScheduleType" block="restriction">
				<xs:annotation>
					<xs:documentation>method=VmScheduleOptions;single_fixed=on;</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="RemoteDisplay" block="restriction">
				<xs:annotation>
					<xs:documentation>class=CVmRemoteDisplay;method=VmRemoteDisplay;single_fixed=on;</xs:documentation>
				</xs:annotation>
				<xs:complexType>
					<xs:sequence>
						<xs:element name="Mode" type="xs:integer" default="PRD_DISABLED" minOccurs="0">
							<xs:annotation>
								<xs:documentation>type=PRL_VM_REMOTE_DISPLAY_MODE;</xs:documentation>
							</xs:annotation>
						</xs:element>
						<xs:element name="Password" type="xs:string"/>
						<xs:element name="HostName" type="xs:string" default='"0.0.0.0"'/>
						<xs:element name="PortNumber" type="xs:integer" default="XML_DEFAULT_REMOTE_DISPLAY_PORT"/>
						<xs:element name="Encrypted" type="xs:boolean" default="false" minOccurs="0"/>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<xs:element name="Tools">
				<xs:annotation>
					<xs:documentation>class=CVmTools;method=VmTools;single_fixed=on;</xs:documentation>
					<xs:documentation source="Patch for shared folders and profiles">post_read_fragment:
    if ( !getVmSharing()-&gt;getHostSharing()-&gt;isEnabled() )
    {
        getVmSharedProfile()-&gt;setEnabled(false);
    }
</xs:documentation>
				</xs:annotation>
				<xs:complexType>
					<xs:sequence>
						<xs:element name="IsolatedVm" type="xs:boolean" minOccurs="0"/>
						<xs:element name="NonAdminToolsUpgrade" type="xs:boolean" default="true" minOccurs="0"/>
						<xs:element name="LockGuestOnSuspend" type="xs:boolean" minOccurs="0"/>
						<xs:element name="Coherence" type="CoherenceType" block="restriction">
							<xs:annotation>
								<xs:documentation>method=VmCoherence;single_fixed=on;</xs:documentation>
							</xs:annotation>
						</xs:element>
						<xs:element name="SharedFolders" type="SharedFoldersType">
							<xs:annotation>
								<xs:documentation>method=VmSharing;single_fixed=on;</xs:documentation>
							</xs:annotation>
						</xs:element>
						<xs:element name="SharedProfile" block="restriction">
							<xs:annotation>
								<xs:documentation>class=CVmSharedProfile;method=VmSharedProfile;single_fixed=on;</xs:documentation>
							</xs:annotation>
							<xs:complexType>
								<xs:sequence>
									<xs:element name="Enabled" type="xs:boolean" default="true"/>
									<xs:element name="UseDesktop" type="xs:boolean" default="true"/>
									<xs:element name="UseDocuments" type="xs:boolean" default="true"/>
									<xs:element name="UsePictures" type="xs:boolean" default="true"/>
									<xs:element name="UseMusic" type="xs:boolean" default="true"/>
									<xs:element name="UseMovies" type="xs:boolean" default="true" minOccurs="0"/>
									<xs:element name="UseDownloads" type="xs:boolean" default="true" minOccurs="0"/>
									<xs:element name="UseTrashBin" type="xs:boolean" default="true" minOccurs="0"/>
								</xs:sequence>
							</xs:complexType>
						</xs:element>
						<xs:element name="SharedApplications" block="restriction">
							<xs:annotation>
								<xs:documentation>class=CVmSharedApplications;method=VmSharedApplications;single_fixed=on;</xs:documentation>
							</xs:annotation>
							<xs:complexType>
								<xs:sequence>
									<xs:element name="FromWinToMac" type="xs:boolean" default="true" minOccurs="0">
										<xs:annotation>
											<xs:documentation>method=WinToMac;</xs:documentation>
										</xs:annotation>
									</xs:element>
									<xs:element name="FromMacToWin" type="xs:boolean" default="true" minOccurs="0">
										<xs:annotation>
											<xs:documentation>method=MacToWin;</xs:documentation>
										</xs:annotation>
									</xs:element>
									<xs:element name="SmartSelect" type="xs:boolean" default="true" minOccurs="0"/>
									<xs:element name="AppInDock" type="xs:integer" default="PDM_APP_IN_DOCK_ALWAYS" minOccurs="0">
										<xs:annotation>
											<xs:documentation>method=ApplicationInDock;type=PRL_APP_IN_DOCK_MODE;</xs:documentation>
										</xs:annotation>
									</xs:element>
									<xs:element name="ShowWindowsAppInDock" type="xs:boolean" default="true" minOccurs="0"/>
									<xs:element name="ShowGuestNotifications" type="xs:boolean" default="true" minOccurs="0"/>
									<xs:element name="BounceDockIconWhenAppFlashes" type="xs:boolean" default="true" minOccurs="0"/>
									<xs:element name="WebApplications">
										<xs:annotation>
											<xs:documentation>single_fixed=on;</xs:documentation>
										</xs:annotation>
										<xs:complexType>
											<xs:sequence>
												<xs:element name="WebBrowser" type="xs:int" default="PSIA_OPEN_DEFAULT">
													<xs:annotation>
														<xs:documentation>type=PRL_TOOLS_SIA_OPEN_IN_TYPES;</xs:documentation>
													</xs:annotation>
												</xs:element>
												<xs:element name="EmailClient" type="xs:int" default="PSIA_OPEN_DEFAULT">
													<xs:annotation>
														<xs:documentation>type=PRL_TOOLS_SIA_OPEN_IN_TYPES;</xs:documentation>
													</xs:annotation>
												</xs:element>
												<xs:element name="FtpClient" type="xs:int" default="PSIA_OPEN_DEFAULT">
													<xs:annotation>
														<xs:documentation>type=PRL_TOOLS_SIA_OPEN_IN_TYPES;</xs:documentation>
													</xs:annotation>
												</xs:element>
												<xs:element name="Newsgroups" type="xs:integer" default="PSIA_OPEN_DEFAULT" minOccurs="0">
													<xs:annotation>
														<xs:documentation>type=PRL_TOOLS_SIA_OPEN_IN_TYPES;</xs:documentation>
													</xs:annotation>
												</xs:element>
												<xs:element name="Rss" type="xs:integer" default="PSIA_OPEN_DEFAULT" minOccurs="0">
													<xs:annotation>
														<xs:documentation>type=PRL_TOOLS_SIA_OPEN_IN_TYPES;</xs:documentation>
													</xs:annotation>
												</xs:element>
												<xs:element name="RemoteAccess" type="xs:integer" default="PSIA_OPEN_DEFAULT" minOccurs="0">
													<xs:annotation>
														<xs:documentation>type=PRL_TOOLS_SIA_OPEN_IN_TYPES;</xs:documentation>
													</xs:annotation>
												</xs:element>
											</xs:sequence>
										</xs:complexType>
									</xs:element>
									<xs:element name="IconGroupingEnabled" type="xs:boolean" default="true" minOccurs="0"/>
									<xs:element name="AddInstalledApplicationsToLaunchpad" type="xs:boolean" default="true" minOccurs="0"/>
								</xs:sequence>
							</xs:complexType>
						</xs:element>
						<xs:element name="AutoUpdate">
							<xs:annotation>
								<xs:documentation>single_fixed=on;</xs:documentation>
							</xs:annotation>
							<xs:complexType>
								<xs:sequence>
									<xs:element name="Enabled" type="xs:boolean" default="true"/>
								</xs:sequence>
							</xs:complexType>
						</xs:element>
						<xs:element name="ClipboardSync" block="restriction">
							<xs:annotation>
								<xs:documentation>single_fixed=on;</xs:documentation>
							</xs:annotation>
							<xs:complexType>
								<xs:sequence>
									<xs:element name="Enabled" type="xs:boolean" default="true">
										<xs:annotation>
											<xs:documentation/>
											<xs:documentation source="patch on">patch:</xs:documentation>
										</xs:annotation>
									</xs:element>
									<xs:element name="PreserveTextFormatting" type="xs:boolean" default="true" minOccurs="0"/>
								</xs:sequence>
							</xs:complexType>
						</xs:element>
						<xs:element name="DragAndDrop">
							<xs:annotation>
								<xs:documentation>single_fixed=on;</xs:documentation>
							</xs:annotation>
							<xs:complexType>
								<xs:sequence>
									<xs:element name="Enabled" type="xs:boolean" default="true">
										<xs:annotation>
											<xs:documentation/>
											<xs:documentation source="patch on">patch:</xs:documentation>
										</xs:annotation>
									</xs:element>
								</xs:sequence>
							</xs:complexType>
						</xs:element>
						<xs:element name="KeyboardLayoutSync">
							<xs:annotation>
								<xs:documentation>class=CVmKeyboardLayoutSync;single_fixed=on;</xs:documentation>
							</xs:annotation>
							<xs:complexType>
								<xs:sequence>
									<xs:element name="Enabled" type="xs:boolean" default="true"/>
								</xs:sequence>
							</xs:complexType>
						</xs:element>
						<xs:element name="MouseSync">
							<xs:annotation>
								<xs:documentation>single_fixed=on;</xs:documentation>
							</xs:annotation>
							<xs:complexType>
								<xs:sequence>
									<xs:element name="Enabled" type="xs:boolean" default="true"/>
								</xs:sequence>
							</xs:complexType>
						</xs:element>
						<xs:element name="MouseVtdSync">
							<xs:annotation>
								<xs:documentation>single_fixed=on;</xs:documentation>
							</xs:annotation>
							<xs:complexType>
								<xs:sequence>
									<xs:element name="Enabled" type="xs:boolean" default="true"/>
								</xs:sequence>
							</xs:complexType>
						</xs:element>
						<xs:element name="SmartMouse">
							<xs:annotation>
								<xs:documentation>single_fixed=on;</xs:documentation>
							</xs:annotation>
							<xs:complexType>
								<xs:sequence>
									<xs:element name="Enabled" type="xs:boolean" default="true"/>
								</xs:sequence>
							</xs:complexType>
						</xs:element>
						<xs:element name="SmoothScrolling">
							<xs:annotation>
								<xs:documentation>single_fixed=on;</xs:documentation>
							</xs:annotation>
							<xs:complexType>
								<xs:sequence>
									<xs:element name="Enabled" type="xs:boolean" default="true"/>
								</xs:sequence>
							</xs:complexType>
						</xs:element>
						<xs:element name="TimeSync" block="restriction">
							<xs:annotation>
								<xs:documentation>class=CVmToolsTimeSync;single_fixed=on;</xs:documentation>
							</xs:annotation>
							<xs:complexType>
								<xs:sequence>
									<xs:element name="Enabled" type="xs:boolean" default="(ParallelsDirs::getAppExecuteMode() == PAM_SERVER ? false : true)"/>
									<xs:element name="SyncInterval" type="xs:integer" default="60">
										<xs:annotation>
											<xs:documentation/>
											<xs:documentation source="patch on">patch:</xs:documentation>
										</xs:annotation>
									</xs:element>
									<xs:element name="KeepTimeDiff" type="xs:boolean" default="true"/>
									<xs:element name="SyncHostToGuest" type="xs:boolean" default="false" minOccurs="0"/>
								</xs:sequence>
							</xs:complexType>
						</xs:element>
						<xs:element name="TisDatabase">
							<xs:annotation>
								<xs:documentation>single_fixed=on;</xs:documentation>
							</xs:annotation>
							<xs:complexType>
								<xs:sequence>
									<xs:element name="Data" type="xs:string"/>
								</xs:sequence>
							</xs:complexType>
						</xs:element>
						<xs:element name="Modality" block="restriction">
							<xs:annotation>
								<xs:documentation>single_fixed=on;class=CVmModality;</xs:documentation>
							</xs:annotation>
							<xs:complexType>
								<xs:sequence>
									<xs:element name="Opacity" type="xs:double" default="1.0">
										<xs:annotation>
											<xs:documentation/>
											<xs:documentation source="patch on">patch:</xs:documentation>
										</xs:annotation>
									</xs:element>
									<xs:element name="StayOnTop" type="xs:boolean" default="false">
										<xs:annotation>
											<xs:documentation/>
											<xs:documentation source="patch on">patch:</xs:documentation>
										</xs:annotation>
									</xs:element>
									<xs:element name="CaptureMouseClicks" type="xs:boolean" default="true"/>
									<xs:element name="UseWhenAppInBackground" type="xs:boolean" default="true" minOccurs="0"/>
								</xs:sequence>
							</xs:complexType>
						</xs:element>
						<xs:element name="SharedVolumes" block="restriction">
							<xs:annotation>
								<xs:documentation>single_fixed=on;class=CVmSharedVolumes;</xs:documentation>
								<xs:documentation>include="Libraries/PrlCommonUtilsBase/ParallelsDirs.h";</xs:documentation>
							</xs:annotation>
							<xs:complexType>
								<xs:sequence>
									<xs:element name="Enabled" type="xs:boolean" default="(ParallelsDirs::getAppExecuteMode() == PAM_SERVER ? false : true)"/>
									<xs:element name="UseExternalDisks" type="xs:boolean" default="true" minOccurs="0"/>
									<xs:element name="UseDVDs" type="xs:boolean" default="true" minOccurs="0"/>
									<xs:element name="UseConnectedServers" type="xs:boolean" default="true" minOccurs="0"/>
									<xs:element name="UseInversedDisks" type="xs:boolean" default="false" minOccurs="0"/>
								</xs:sequence>
							</xs:complexType>
						</xs:element>
						<xs:element name="Gestures">
							<xs:annotation>
								<xs:documentation>single_fixed=on;class=CVmGestures;</xs:documentation>
							</xs:annotation>
							<xs:complexType>
								<xs:sequence>
									<xs:element name="Enabled" type="xs:boolean" default="true">
										<xs:annotation>
											<xs:documentation/>
											<xs:documentation source="patch on">patch:</xs:documentation>
										</xs:annotation>
									</xs:element>
									<xs:element name="OneFingerSwipe" type="xs:boolean" default="true" minOccurs="0"/>
								</xs:sequence>
							</xs:complexType>
						</xs:element>
						<xs:element name="RemoteControl">
							<xs:annotation>
								<xs:documentation>single_fixed=on;class=CVmRemoteControl;</xs:documentation>
							</xs:annotation>
							<xs:complexType>
								<xs:sequence>
									<xs:element name="Enabled" type="xs:boolean" default="true"/>
								</xs:sequence>
							</xs:complexType>
						</xs:element>
						<xs:element name="NativeLook">
							<xs:annotation>
								<xs:documentation>single_fixed=on;class=CVmNativeLook;</xs:documentation>
							</xs:annotation>
							<xs:complexType>
								<xs:sequence>
									<xs:element name="Enabled" type="xs:boolean"/>
								</xs:sequence>
							</xs:complexType>
						</xs:element>
						<xs:element name="AutoSyncOSType">
							<xs:annotation>
								<xs:documentation>single_fixed=on;class=CVmAutoSyncOSType;</xs:documentation>
							</xs:annotation>
							<xs:complexType>
								<xs:sequence>
									<xs:element name="Enabled" type="xs:boolean" default="true"/>
								</xs:sequence>
							</xs:complexType>
						</xs:element>
						<xs:element name="Win7Look">
							<xs:annotation>
								<xs:documentation>single_fixed=on;class=CVmWin7Look;</xs:documentation>
							</xs:annotation>
							<xs:complexType>
								<xs:sequence>
									<xs:element name="Enabled" type="xs:boolean"/>
								</xs:sequence>
							</xs:complexType>
						</xs:element>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<xs:element name="Autoprotect">
				<xs:annotation>
					<xs:documentation>class=CVmAutoprotect;method=VmAutoprotect;single_fixed=on;</xs:documentation>
				</xs:annotation>
				<xs:complexType>
					<xs:sequence>
						<xs:element name="Enabled" type="xs:boolean" default="false"/>
						<xs:element name="Period" default="60*60*24">
							<xs:annotation>
								<xs:documentation/>
								<xs:documentation source="patch on">patch:</xs:documentation>
							</xs:annotation>
							<xs:simpleType>
								<xs:restriction base="xs:integer">
									<xs:minInclusive value="3600"/>
									<xs:maxInclusive value="172800"/>
								</xs:restriction>
							</xs:simpleType>
						</xs:element>
						<xs:element name="TotalSnapshots" default="10">
							<xs:simpleType>
								<xs:restriction base="xs:integer">
									<xs:minInclusive value="1"/>
									<xs:maxInclusive value="100"/>
								</xs:restriction>
							</xs:simpleType>
						</xs:element>
						<xs:element name="Schema" type="xs:integer" default="PVSS_CUSTOM" minOccurs="0">
							<xs:annotation>
								<xs:documentation>type=PRL_VM_SMARTGUARD_SCHEMA;</xs:documentation>
							</xs:annotation>
						</xs:element>
						<xs:element name="NotifyBeforeCreation" type="xs:boolean" default="true" minOccurs="0"/>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<xs:element name="AutoCompress">
				<xs:annotation>
					<xs:documentation>class=CVmAutoCompress;method=VmAutoCompress;single_fixed=on;</xs:documentation>
				</xs:annotation>
				<xs:complexType>
					<xs:sequence>
						<xs:element name="Enabled" type="xs:boolean" default="(ParallelsDirs::getAppExecuteMode() == PAM_SERVER ? false : true)"/>
						<xs:element name="Period" type="xs:integer" default="24*60*60">
							<xs:annotation>
								<xs:documentation>In seconds</xs:documentation>
							</xs:annotation>
						</xs:element>
						<xs:element name="FreeDiskSpaceRatio" type="xs:double" default="50.0">
							<xs:annotation>
								<xs:documentation>Percentage</xs:documentation>
							</xs:annotation>
						</xs:element>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<xs:element name="GlobalNetwork" type="GlobalNetworkType">
				<xs:annotation>
					<xs:documentation>single_fixed=on;</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="VmEncryptionInfo">
				<xs:annotation>
					<xs:documentation>single_fixed=on;class=CVmEncryption;method=VmEncryption;</xs:documentation>
				</xs:annotation>
				<xs:complexType>
					<xs:sequence>
						<xs:element name="Enabled" type="xs:boolean"/>
						<xs:element name="PluginId" type="xs:string" minOccurs="0"/>
						<xs:element name="Hash1" type="xs:string">
							<xs:annotation>
								<xs:documentation>method=UserPasswordReference;</xs:documentation>
							</xs:annotation>
						</xs:element>
						<xs:element name="Hash2" type="xs:string">
							<xs:annotation>
								<xs:documentation>method=MasterPasswordHash;</xs:documentation>
							</xs:annotation>
						</xs:element>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<xs:element name="VmProtectionInfo">
				<xs:annotation>
					<xs:documentation>single_fixed=on;class=CVmProtection;method=VmProtection;</xs:documentation>
				</xs:annotation>
				<xs:complexType>
					<xs:sequence>
						<xs:element name="Enabled" type="xs:boolean"/>
						<xs:element name="Hash1" type="xs:string">
							<xs:annotation>
								<xs:documentation>method=ProtectionReference;</xs:documentation>
							</xs:annotation>
						</xs:element>
						<xs:element name="Hash2" type="xs:string">
							<xs:annotation>
								<xs:documentation>method=ProtectionHash;</xs:documentation>
							</xs:annotation>
						</xs:element>
						<xs:element name="Hash3" type="xs:string" minOccurs="0">
							<xs:annotation>
								<xs:documentation>method=ExpirationStartDateHash;</xs:documentation>
							</xs:annotation>
						</xs:element>
						<xs:element name="ExpirationInfo">
							<xs:annotation>
								<xs:documentation>single_fixed=on;class=CVmExpiration;method=ExpirationInfo;include=&lt;Build/Current-locale.ver&gt;</xs:documentation>
							</xs:annotation>
							<xs:complexType>
								<xs:sequence>
									<xs:element name="Enabled" type="xs:boolean" minOccurs="0"/>
									<xs:element name="ExpirationDate" type="xs:dateTime" minOccurs="0">
										<xs:annotation>
											<xs:documentation>method=ExpirationDate;default=QDateTime(
													QDateTime::fromString(XML_DEFAULT_DATE_TIME, XML_DATETIME_FORMAT).date(),
													QDateTime::fromString(XML_DEFAULT_DATE_TIME, XML_DATETIME_FORMAT).time(),
													Qt::UTC);</xs:documentation>
										</xs:annotation>
									</xs:element>
									<xs:element name="TrustedTimeServerUrl" type="xs:anyURI" minOccurs="0"/>
									<xs:element name="Note" type="xs:string" minOccurs="0"/>
									<xs:element name="TimeCheckIntervalSeconds" type="xs:integer" minOccurs="0"/>
									<xs:element name="OfflineTimeToLiveSeconds" type="xs:integer" minOccurs="0"/>
								</xs:sequence>
							</xs:complexType>
						</xs:element>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<xs:element name="SharedCamera">
				<xs:annotation>
					<xs:documentation>single_fixed=on;class=CVmSharedCamera;</xs:documentation>
				</xs:annotation>
				<xs:complexType>
					<xs:sequence>
						<xs:element name="Enabled" type="xs:boolean" default="true">
							<xs:annotation>
								<xs:documentation/>
								<xs:documentation source="patch on">patch:</xs:documentation>
							</xs:annotation>
						</xs:element>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<xs:element name="VirtualPrintersInfo">
				<xs:annotation>
					<xs:documentation>single_fixed=on;class=CVmVirtualPrintersInfo;</xs:documentation>
				</xs:annotation>
				<xs:complexType>
					<xs:sequence>
						<xs:element name="UseHostPrinters" type="xs:boolean" default="true">
							<xs:annotation>
								<xs:documentation/>
								<xs:documentation source="patch mech on">patch:</xs:documentation>
							</xs:annotation>
						</xs:element>
						<xs:element name="SyncDefaultPrinter" type="xs:boolean" default="true"/>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<xs:element name="SharedBluetooth">
				<xs:annotation>
					<xs:documentation>single_fixed=on;class=CVmSharedBluetooth;</xs:documentation>
				</xs:annotation>
				<xs:complexType>
					<xs:sequence>
						<xs:element name="Enabled" type="xs:boolean" default="false">
							<xs:annotation>
								<xs:documentation/>
								<xs:documentation source="patch on">patch:</xs:documentation>
							</xs:annotation>
						</xs:element>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<xs:element name="LockDown">
				<xs:annotation>
					<xs:documentation>single_fixed=on;class=CVmLockDown;</xs:documentation>
				</xs:annotation>
				<xs:complexType>
					<xs:sequence>
						<xs:element name="Hash" type="xs:string"/>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<xs:element name="UsbController">
				<xs:annotation>
					<xs:documentation>single_fixed=on;class=CVmUsbController;</xs:documentation>
				</xs:annotation>
				<xs:complexType>
					<xs:sequence>
						<xs:element name="UhcEnabled" type="xs:boolean" default="true">
							<xs:annotation>
								<xs:documentation/>
								<xs:documentation source="patch on">patch:</xs:documentation>
							</xs:annotation>
						</xs:element>
						<xs:element name="EhcEnabled" type="xs:boolean" default="true"/>
						<xs:element name="XhcEnabled" type="xs:boolean" default="false"/>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<xs:element name="HighAvailability">
				<xs:annotation>
					<xs:documentation>single_fixed=on;class=CVmHighAvailability;</xs:documentation>
				</xs:annotation>
				<xs:complexType>
					<xs:sequence>
						<xs:element name="Enabled" type="xs:boolean" default="true"/>
						<xs:element name="Priority" type="xs:integer" default="0"/>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<xs:element name="OnlineCompact">
				<xs:annotation>
					<xs:documentation>single_fixed=on;class=CVmOnlineCompact;</xs:documentation>
				</xs:annotation>
				<xs:complexType>
					<xs:sequence>
						<xs:element name="Mode" type="xs:integer" default="POCM_AUTO">
							<xs:annotation>
								<xs:documentation>type=PRL_ONLINE_COMPACT_MODE;</xs:documentation>
							</xs:annotation>
						</xs:element>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
		</xs:sequence>
	</xs:complexType>
	<xs:complexType name="SharedFolderType">
		<xs:annotation>
			<xs:documentation>class=CVmSharedFolder;</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="Name" type="xs:string">
				<xs:annotation>
					<xs:documentation>method=Name;attribute=name;</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element ref="Path"/>
			<xs:element name="FolderDescription" type="xs:string">
				<xs:annotation>
					<xs:documentation>method=Description;</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element ref="ReadOnly"/>
			<xs:element name="Enabled" type="xs:boolean" default="true"/>
		</xs:sequence>
	</xs:complexType>
	<xs:complexType name="SharedFoldersType">
		<xs:annotation>
			<xs:documentation>class=CVmSharing;</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="HostSharing" block="restriction">
				<xs:annotation>
					<xs:documentation>class=CVmHostSharing;single_fixed=on;</xs:documentation>
					<xs:documentation source="addSharedFolder">header_fragment:
    // Add shared folder to the list
    void addSharedFolder(CVmSharedFolder* item);
</xs:documentation>
					<xs:documentation source="addSharedFolder_impl">unit_fragment:
void CVmHostSharing::addSharedFolder(CVmSharedFolder* item)
{
	m_lstSharedFolders.append( item );
}
</xs:documentation>
				</xs:annotation>
				<xs:complexType>
					<xs:sequence>
						<xs:element name="Enabled" type="xs:boolean" default="true"/>
						<xs:element name="ShareAllMacDisks" type="xs:boolean" default="true"/>
						<xs:element name="ShareUserHomeDir" type="xs:boolean" default="true"/>
						<xs:element name="MapSharedFoldersOnLetters" type="xs:boolean" default="true">
							<xs:annotation>
								<xs:documentation/>
								<xs:documentation source="patch on">patch:</xs:documentation>
							</xs:annotation>
						</xs:element>
						<xs:element name="UserDefinedFoldersEnabled" type="xs:boolean" default="false" minOccurs="0"/>
						<xs:element name="SetExecBitForFiles" type="xs:boolean" minOccurs="0"/>
						<xs:element name="VirtualLinks" type="xs:boolean" default="true" minOccurs="0"/>
						<xs:element name="EnableDos8dot3Names" type="xs:boolean" default="true" minOccurs="0"/>
						<xs:element name="SharedFolder" type="SharedFolderType" minOccurs="0" maxOccurs="unbounded">
							<xs:annotation>
								<xs:documentation>list=SharedFolders;</xs:documentation>
							</xs:annotation>
						</xs:element>
						<xs:element name="SharedCloud" type="xs:boolean" default="true" minOccurs="0"/>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<xs:element name="GuestSharing" block="restriction">
				<xs:annotation>
					<xs:documentation>class=CVmGuestSharing;single_fixed=on;</xs:documentation>
				</xs:annotation>
				<xs:complexType>
					<xs:sequence>
						<xs:element name="Enabled" type="xs:boolean" default="true"/>
						<xs:element name="AutoMount" type="xs:boolean" default="true"/>
						<xs:element name="AutoMountNetworkDrives" type="xs:boolean" default="false" minOccurs="0"/>
						<xs:element name="EnableSpotlight" type="xs:boolean" default="false"/>
						<xs:element name="AutoMountCloudDrives" type="xs:boolean" default="true" minOccurs="0"/>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
		</xs:sequence>
	</xs:complexType>
	<xs:element name="ShowTaskBar" type="xs:boolean" default="XML_DEFAULT_CHRN_SHOWTASKBAR">
		<xs:annotation>
			<xs:documentation/>
			<xs:documentation source="patch on">patch:</xs:documentation>
		</xs:annotation>
	</xs:element>
	<xs:complexType name="SoundType">
		<xs:annotation>
			<xs:documentation>class=CVmSoundDevice;base_class=CVmDevice;object_id=on;</xs:documentation>
			<xs:documentation source="Comparision operator">header_fragment:
    virtual bool operator==( const CVmSoundDevice&amp; cVmSoundDevice );
</xs:documentation>
			<xs:documentation source="Comparision operator_impl">unit_fragment:
bool CVmSoundDevice::operator==( const CVmSoundDevice&amp; cVmSoundDevice )
{
	if (CVmDevice::operator ==(cVmSoundDevice))
	{
		if (
			(getOutputDevice() == cVmSoundDevice.getOutputDevice())
			 &amp;&amp; (getMixerDevice() == cVmSoundDevice.getMixerDevice())
			 &amp;&amp; getSoundInputs()-&gt;toString() == cVmSoundDevice.getSoundInputs()-&gt;toString()
			 &amp;&amp; getSoundOutputs()-&gt;toString() == cVmSoundDevice.getSoundOutputs()-&gt;toString()
			)
			return true;
		
	}
	return false;
}
</xs:documentation>
			<xs:documentation source="getDeviceType">header_fragment:
    virtual PRL_DEVICE_TYPE getDeviceType() const { return PDE_SOUND_DEVICE; }
</xs:documentation>
			<xs:documentation source="getEmulatedType">header_fragment:
    PVE::SoundDeviceEmulatedType getEmulatedType() const { return (PVE::SoundDeviceEmulatedType )CVmDevice::getEmulatedType(); }
</xs:documentation>
			<xs:documentation source="Declare input/output classes">prefix_class_info:
class CVmSoundInputs;
class CVmSoundOutputs;
#define CVMSOUNDINPUTS_H
#define CVMSOUNDOUTPUTS_H
</xs:documentation>
			<xs:documentation source="Undef input/output include skipping">post_class_info:
#undef CVMSOUNDINPUTS_H
#undef CVMSOUNDOUTPUTS_H
</xs:documentation>
			<xs:documentation source="include input/output classes">unit_fragment:
#include "CVmSoundInputs.h"
#include "CVmSoundOutputs.h"
</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="Enabled" type="xs:integer">
				<xs:annotation>
					<xs:documentation>method_base_class=CVmDevice;type=PVE::DeviceEnabledState;</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Connected" type="xs:integer">
				<xs:annotation>
					<xs:documentation>method_base_class=CVmDevice;type=PVE::DeviceConnectedState;</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="EmulatedType" type="xs:integer">
				<xs:annotation>
					<xs:documentation>method_base_class=CVmDevice;default=PVE::AC97;</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="SystemName" type="xs:string">
				<xs:annotation>
					<xs:documentation>method_base_class=CVmDevice;</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="UserFriendlyName" type="xs:string">
				<xs:annotation>
					<xs:documentation>method_base_class=CVmDevice;</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Remote" type="xs:boolean">
				<xs:annotation>
					<xs:documentation>method_base_class=CVmDevice;</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Output" type="xs:string" default="PRL_SOUND_DEFAULT_DEVICE_NAME">
				<xs:annotation>
					<xs:documentation>method=OutputDevice;</xs:documentation>
					<xs:documentation source="patch init default name">patch:
	if ( Output_patch_stamp != "1" )
	{
		if (getOutputDevice().isEmpty())
			setOutputDevice(PRL_SOUND_DEFAULT_DEVICE_NAME);
		Output_patch_stamp = "1";
	}</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Mixer" type="xs:string" default="PRL_SOUND_DEFAULT_DEVICE_NAME" minOccurs="0">
				<xs:annotation>
					<xs:documentation>method=MixerDevice;</xs:documentation>
					<xs:documentation source="patch init default name">patch:
	if ( Mixer_patch_stamp != "1" )
	{
		if (getMixerDevice().isEmpty())
			setMixerDevice(PRL_SOUND_DEFAULT_DEVICE_NAME);
		Mixer_patch_stamp = "1";
	}</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Channel" type="xs:integer" default="PSCT_AUTO" minOccurs="0">
				<xs:annotation>
					<xs:documentation>type=PRL_SOUND_CHANNEL_TYPE;</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="SoundInputs">
				<xs:annotation>
					<xs:documentation>single_fixed=on;class=CVmSoundInputs;</xs:documentation>
				</xs:annotation>
				<xs:complexType>
					<xs:sequence>
						<xs:element name="Sound" type="SoundType" minOccurs="0" maxOccurs="unbounded"/>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<xs:element name="SoundOutputs">
				<xs:annotation>
					<xs:documentation>single_fixed=on;class=CVmSoundOutputs;</xs:documentation>
				</xs:annotation>
				<xs:complexType>
					<xs:sequence>
						<xs:element name="Sound" type="SoundType" minOccurs="0" maxOccurs="unbounded"/>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<xs:element name="DeviceDescription" type="xs:string" minOccurs="0">
				<xs:annotation>
					<xs:documentation>method=Description;method_base_class=CVmDevice;</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
	</xs:complexType>
	<xs:element name="StackIndex" type="xs:integer"/>
	<xs:complexType name="StartupType">
		<xs:annotation>
			<xs:documentation>class=CVmStartupOptions;extern=CVmStartupOptions.h;sub_class=CVmStartupOptionsBase;</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="AutoStart" type="xs:integer" default="PAO_VM_START_MANUAL">
				<xs:annotation>
					<xs:documentation>type=PRL_VM_AUTOSTART_OPTION;</xs:documentation>
					<xs:documentation source="patch on">patch:</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="AutoStartDelay" type="xs:integer" minOccurs="0"/>
			<xs:element name="VmStartLoginMode" type="xs:integer" default="PLM_START_ACCOUNT" minOccurs="0">
				<xs:annotation>
					<xs:documentation>type=PRL_VM_START_LOGIN_MODE;</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="VmFastRebootUser" type="xs:string" minOccurs="0"/>
			<xs:element name="VmStartAsUser" type="xs:string" minOccurs="0"/>
			<xs:element name="VmStartAsPassword" type="xs:string" minOccurs="0"/>
			<xs:element name="ChangedPassword" type="xs:boolean" minOccurs="0">
				<xs:annotation>
					<xs:documentation source="Tag condition">condition:isChangedPassword()</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="WindowMode" type="xs:integer" default="PWM_DEFAULT_WINDOW_MODE">
				<xs:annotation>
					<xs:documentation>type=PRL_VM_WINDOW_MODE;</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="LockInFullScreenMode" type="xs:boolean" default="false" minOccurs="0"/>
			<xs:element name="StartInDetachedWindow" type="xs:boolean" default="false" minOccurs="0"/>
			<xs:element name="BootingOrder" block="restriction">
				<xs:annotation>
					<xs:documentation>single_fixed=on;</xs:documentation>
				</xs:annotation>
				<xs:complexType>
					<xs:sequence>
						<xs:element name="BootDevice" minOccurs="0" maxOccurs="unbounded">
							<xs:annotation>
								<xs:documentation>class=CVmBootDeviceBase;extern=BootDevice.h;sub_class=BootDevice;</xs:documentation>
								<xs:documentation source="CVmBootDeviceBase">post_class_info:
class CVmBootDeviceBase : public BootDevice
{
public:
	CVmBootDeviceBase()
	: BootDevice(),
	  deviceType(m_ctType),
	  deviceIndex(m_uiIndex),
	  sequenceNumber(m_uiBootingNumber),
	  inUseStatus(m_bInUse)
	{
	}
	CVmBootDeviceBase(const CVmBootDeviceBase&amp; bd)
	: BootDevice(bd),
	  deviceType(m_ctType),
	  deviceIndex(m_uiIndex),
	  sequenceNumber(m_uiBootingNumber),
	  inUseStatus(m_bInUse)
	{
	}
	CVmBootDeviceBase(const CVmBootDeviceBase* pBd)
	: BootDevice(pBd),
	  deviceType(m_ctType),
	  deviceIndex(m_uiIndex),
	  sequenceNumber(m_uiBootingNumber),
	  inUseStatus(m_bInUse)
	{
	}
	virtual ~CVmBootDeviceBase()
	{
	}
	CVmBootDeviceBase( PRL_DEVICE_TYPE devType, uint devIdx, uint numb, bool inUse ) :
	deviceType(m_ctType),
	deviceIndex(m_uiIndex),
	sequenceNumber(m_uiBootingNumber),
	inUseStatus(m_bInUse)
	{
		deviceType =  devType;
		deviceIndex = devIdx;
		sequenceNumber = numb;
		inUseStatus = inUse;
	}
	// compare operator
	bool operator==( const CVmBootDeviceBase&amp; cVmBootDevice)
	{
		if ((deviceType == cVmBootDevice.deviceType) &amp;&amp;
		(deviceIndex == cVmBootDevice.deviceIndex) &amp;&amp;
		(sequenceNumber == cVmBootDevice.sequenceNumber) &amp;&amp;
		(inUseStatus == cVmBootDevice.inUseStatus)
		)
			return true;
		return false;
	};
public:
        // Device type
        PRL_DEVICE_TYPE&amp; deviceType;
        // Device index
        uint&amp; deviceIndex;
        // Number of this device in the booting sequence
        uint&amp; sequenceNumber;
        // A flag shows either the device is used in the booting process
        bool&amp; inUseStatus;
};
</xs:documentation>
							</xs:annotation>
							<xs:complexType>
								<xs:sequence>
									<xs:element name="Index" type="xs:integer">
										<xs:annotation>
											<xs:documentation>attribute=index;</xs:documentation>
										</xs:annotation>
									</xs:element>
									<xs:element name="Type" type="xs:integer" default="PDE_HARD_DISK">
										<xs:annotation>
											<xs:documentation>type=PRL_DEVICE_TYPE;</xs:documentation>
										</xs:annotation>
									</xs:element>
									<xs:element name="BootingNumber" type="xs:integer"/>
									<xs:element name="InUse" type="xs:boolean"/>
								</xs:sequence>
							</xs:complexType>
						</xs:element>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<xs:element name="AllowSelectBootDevice" type="xs:boolean" default="false" minOccurs="0"/>
			<xs:element name="FastReboot" type="xs:boolean" default="false" minOccurs="0"/>
			<xs:element name="Bios">
				<xs:annotation>
					<xs:documentation>class=CVmStartupBios;single_fixed=on;</xs:documentation>
					<xs:documentation source="Bios type">header_fragment:
	PRL_BIOS_TYPE getType() const { return isEfiEnabled() ? PBT_EFI : PBT_LEGACY; }
	void setType(PRL_BIOS_TYPE nType) { setEfiEnabled(nType ? true : false); }
</xs:documentation>
				</xs:annotation>
				<xs:complexType>
					<xs:sequence>
						<xs:element name="EfiEnabled" type="xs:boolean" minOccurs="0"/>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<xs:element name="ExternalDeviceSystemName" type="xs:string" minOccurs="0"/>
		</xs:sequence>
	</xs:complexType>
	<xs:element name="SystemFlags" type="xs:string"/>
	<xs:element name="Type" type="xs:integer"/>
	<xs:complexType name="USBType">
		<xs:annotation>
			<xs:documentation>class=CVmUsbDevice;base_class=CVmDevice;object_id=on;</xs:documentation>
			<xs:documentation source="Comparision operator">header_fragment:
    virtual bool operator==( const CVmUsbDevice&amp; cVmUsbDevice );
</xs:documentation>
			<xs:documentation source="Comparision operator_impl">unit_fragment:
bool CVmUsbDevice::operator==( const CVmUsbDevice&amp; cVmUsbDevice )
{
	if (CVmDevice::operator ==(cVmUsbDevice ))
	{
		if (getAutoconnectDevices() == cVmUsbDevice.getAutoconnectDevices())
			return true;
		
	}
	return false;
}
</xs:documentation>
			<xs:documentation source="getDeviceType">header_fragment:
    virtual PRL_DEVICE_TYPE getDeviceType() const { return PDE_USB_DEVICE; }
</xs:documentation>
			<xs:documentation source="getEmulatedType">header_fragment:
    PVE::UsbDeviceEmulatedType getEmulatedType() const { return (PVE::UsbDeviceEmulatedType )CVmDevice::getEmulatedType(); }
</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="Enabled" type="xs:integer">
				<xs:annotation>
					<xs:documentation>method_base_class=CVmDevice;type=PVE::DeviceEnabledState;</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Connected" type="xs:integer">
				<xs:annotation>
					<xs:documentation>method_base_class=CVmDevice;type=PVE::DeviceConnectedState;</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="EmulatedType" type="xs:integer">
				<xs:annotation>
					<xs:documentation>method_base_class=CVmDevice;default=PVE::RealUsbDevice;</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="SystemName" type="xs:string">
				<xs:annotation>
					<xs:documentation>method_base_class=CVmDevice;</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="UserFriendlyName" type="xs:string">
				<xs:annotation>
					<xs:documentation>method_base_class=CVmDevice;</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Remote" type="xs:boolean">
				<xs:annotation>
					<xs:documentation>method_base_class=CVmDevice;</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="AutoConnect" type="xs:integer" default="PUD_CONNECT_TO_GUEST_OS">
				<xs:annotation>
					<xs:documentation>method=AutoconnectDevices;type=PRL_USB_DEVICE_AUTO_CONNECT_OPTION;</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="ConnectReason" type="xs:integer" default="PUD_CONNECTED_MANUALLY" minOccurs="0">
				<xs:annotation>
					<xs:documentation>type=PRL_USB_DEVICE_CONNECT_REASON;</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="DeviceDescription" type="xs:string" minOccurs="0">
				<xs:annotation>
					<xs:documentation>method=Description;method_base_class=CVmDevice;</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="CACSupportEnabled" type="xs:boolean" minOccurs="0"/>
			<xs:element name="UsbType" type="xs:integer" minOccurs="0">
				<xs:annotation>
					<xs:documentation>type=PRL_USB_DEVICE_TYPE;default=PUDT_OTHER;</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
	</xs:complexType>
	<xs:element name="Video" type="xs:integer"/>
	<xs:element name="VmDescription" type="xs:string"/>
	<xs:element name="VmHome" type="xs:string">
		<xs:annotation>
			<xs:documentation>method=HomePath;</xs:documentation>
			<xs:documentation source="Tag condition">condition:!m_qsVmHome.isEmpty() &amp;&amp; !m_qsVmHome.isNull()</xs:documentation>
		</xs:annotation>
	</xs:element>
	<xs:element name="VmName" type="xs:string"/>
	<xs:element name="VmUuid" type="xs:string">
		<xs:annotation>
			<xs:documentation>default=Uuid::createUuid().toString();</xs:documentation>
		</xs:annotation>
	</xs:element>
	<xs:element name="Width" type="xs:integer"/>
	<xs:element name="WindowMode" type="xs:integer"/>
	<xs:complexType name="ParallelsVirtualApplianceType">
		<xs:annotation>
			<xs:documentation>class=CVaConfig;</xs:documentation>
			<xs:documentation source="DownloadUrls">header_fragment:
	const QStringList* getDownloadUrls() const
	{ return (QStringList* )&amp;m_lstDownloadURL; }
	void addDownloadUrl( const QString&amp; value )
	{ m_lstDownloadURL.append( value ); }
	void deleteDownloadUrl( const QString&amp; value )
	{ m_lstDownloadURL.removeAll( value ); }
	bool hasDownloadUrl( const QString&amp; value )
	{ return m_lstDownloadURL.contains( value ); }
	void clearDownloadUrls() { m_lstDownloadURL.clear(); }
</xs:documentation>
			<xs:documentation source="AdminInterfaces">header_fragment:
	const QList&lt;CVaAdminInterface* &gt;* getAdminInterfaces() const
	{ return &amp;m_lstAdminInterfaces; }
	void addAdminInterface( CVaAdminInterface* value )
	{ m_lstAdminInterfaces.append( value ); }
	void clearAdminInterfaces();
</xs:documentation>
			<xs:documentation source="AdminInterfaces_impl">unit_fragment:
void CVaConfig::clearAdminInterfaces()
{
	for ( int i =0; i &lt; m_lstAdminInterfaces.count(); i++ )
		delete m_lstAdminInterfaces.at( i );
	m_lstAdminInterfaces.clear();
}
</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="Category" type="xs:integer" default="PVE::VaCategoryDevelopment">
				<xs:annotation>
					<xs:documentation>PVA functional category</xs:documentation>
					<xs:documentation>type=PVE::VaCategory;</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Title" type="xs:string">
				<xs:annotation>
					<xs:documentation>PVA name</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Abstract" type="xs:string">
				<xs:annotation>
					<xs:documentation>Short description</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Licences">
				<xs:annotation>
					<xs:documentation>single_fixed=on;</xs:documentation>
				</xs:annotation>
				<xs:complexType>
					<xs:complexContent>
						<xs:extension base="LicencesType"/>
					</xs:complexContent>
				</xs:complexType>
			</xs:element>
			<xs:element name="DevelopmentStatus" type="xs:integer" default="PVE::VaDevelopmentStatusDevelopment">
				<xs:annotation>
					<xs:documentation>Development status</xs:documentation>
					<xs:documentation>type=PVE::VaDevelopmentStatus;</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Version" type="xs:string">
				<xs:annotation>
					<xs:documentation>PVA's version</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="LastUpdate" type="xs:string">
				<xs:annotation>
					<xs:documentation>Last PVA's update date</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="OsUtilized" type="xs:string">
				<xs:annotation>
					<xs:documentation>Os used in guest</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Requirements" type="RequirementsType">
				<xs:annotation>
					<xs:documentation>single_fixed=on;</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="PackageSize" type="xs:string">
				<xs:annotation>
					<xs:documentation>Size of PVA's package</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Description" type="xs:string">
				<xs:annotation>
					<xs:documentation>Full description of the PVA</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="ToolsVersion" type="xs:string">
				<xs:annotation>
					<xs:documentation>Tools version If they are installed</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="AdminInterface" type="AdminInterfaceType" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>Administration interfaces for PVA</xs:documentation>
					<xs:documentation>list=AdminInterfaces;</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="DownloadURL" type="xs:string" minOccurs="0" maxOccurs="unbounded"/>
			<xs:element name="AuthorName" type="xs:string"/>
			<xs:element name="AuthorEmail" type="xs:string"/>
		</xs:sequence>
	</xs:complexType>
	<xs:complexType name="LicencesType">
		<xs:annotation>
			<xs:documentation>class=CVaLicences;</xs:documentation>
			<xs:documentation source="List">header_fragment:
	const QStringList* getLicences() const { return (QStringList* )&amp;m_lstList; }
	void addLicence( const QString&amp; value ) { m_lstList.append( value ); }
	void deleteLicence( const QString&amp; value ) { m_lstList.removeAll( value ); }
	bool hasLicence( const QString&amp; value ) { return m_lstList.contains( value ); }
	void clearLicences() { m_lstList.clear(); }
</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="IsCommercial" type="xs:boolean">
				<xs:annotation>
					<xs:documentation>Is any commercial license used by the PVA?</xs:documentation>
					<xs:documentation>method=Commercial;</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="List" type="xs:string" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>List of licences used</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
	</xs:complexType>
	<xs:simpleType name="CategoryType">
		<xs:restriction base="xs:integer">
			<xs:enumeration value="2"/>
			<xs:enumeration value="3"/>
			<xs:enumeration value="4"/>
			<xs:enumeration value="5"/>
			<xs:enumeration value="6"/>
			<xs:enumeration value="7"/>
			<xs:enumeration value="8"/>
			<xs:enumeration value="9"/>
			<xs:enumeration value="10"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="DevStatusType">
		<xs:restriction base="xs:integer">
			<xs:enumeration value="1"/>
			<xs:enumeration value="2"/>
			<xs:enumeration value="3"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:complexType name="AdminInterfaceType">
		<xs:annotation>
			<xs:documentation>Administration interface type</xs:documentation>
			<xs:documentation>class=CVaAdminInterface;</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="URL" type="xs:integer">
				<xs:annotation>
					<xs:documentation>URL of interface access</xs:documentation>
					<xs:documentation>method=Url;</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Login" type="xs:string">
				<xs:annotation>
					<xs:documentation>Administration login</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Password" type="xs:string">
				<xs:annotation>
					<xs:documentation>Administration password</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
	</xs:complexType>
	<xs:complexType name="RequirementsType">
		<xs:annotation>
			<xs:documentation>Hardware requirements for running the PVA</xs:documentation>
			<xs:documentation>class=CVaRequirements;</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="CPU" type="xs:string">
				<xs:annotation>
					<xs:documentation>CPU type</xs:documentation>
					<xs:documentation>method=CpuType;</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Memory" type="xs:string">
				<xs:annotation>
					<xs:documentation>Memory size</xs:documentation>
					<xs:documentation>method=MemorySize;</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Disk" type="xs:string">
				<xs:annotation>
					<xs:documentation>Disks size</xs:documentation>
					<xs:documentation>method=DiskSize;</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Other" type="xs:string">
				<xs:annotation>
					<xs:documentation>Any others requirements</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
	</xs:complexType>
	<xs:complexType name="NetPktFilterType">
		<xs:annotation>
			<xs:documentation>class=CNetPktFilter;</xs:documentation>
			<xs:documentation source="Comparision operator">header_fragment:
    virtual bool operator==( const CNetPktFilter&amp; cCNetPktFilter);
</xs:documentation>
			<xs:documentation source="Comparision operator_impl">unit_fragment:
bool CNetPktFilter::operator==( const CNetPktFilter&amp; cNetPktFilter)
{
    if (isPreventPromisc() == cNetPktFilter.isPreventPromisc()
	&amp;&amp; isPreventMacSpoof() == cNetPktFilter.isPreventMacSpoof()
	&amp;&amp; isPreventIpSpoof() == cNetPktFilter.isPreventIpSpoof())
    {
        return true;
    }

    return false;
}
</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="PreventPromisc" type="xs:boolean" default="true">
				<xs:annotation>
					<xs:documentation>Prevent receive of not directed to VM packets</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="PreventMacSpoof" type="xs:boolean" default="true">
				<xs:annotation>
					<xs:documentation>When TRUE, adapter is allowed to do sends only from its own MAC address</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="PreventIpSpoof" type="xs:boolean" default="true">
				<xs:annotation>
					<xs:documentation>When TRUE, the guest is allowed to do sends only from addresses in the adapter NetAdrresses list</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
	</xs:complexType>
</xs:schema>
