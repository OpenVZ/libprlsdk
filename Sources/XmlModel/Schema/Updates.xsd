<?xml version="1.0" encoding="UTF-8"?>
<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema" elementFormDefault="qualified" attributeFormDefault="unqualified">
	<xs:element name="ParallelsUpdates">
		<xs:annotation>
			<xs:documentation>class=CUpdates;</xs:documentation>
			<xs:documentation source="Product">header_fragment:
	// Get updating products
	const QList&lt;CUpdProduct* &gt;* getUpdProducts() const
		{ return &amp;m_lstProduct; }
	// Add a updating product to the list
	void addProduct( CUpdProduct* ); 
	// Get a product by its name
	CUpdProduct* getProductByName( const QString&amp; qsName ) const;
</xs:documentation>
			<xs:documentation source="Product_impl">unit_fragment:
void CUpdates::addProduct( CUpdProduct* pProduct )
{
	m_lstProduct.append( pProduct );
}

CUpdProduct* CUpdates::getProductByName( const QString&amp; qsName ) const
{
	 for ( int i = 0; i &lt; m_lstProduct.size(); ++i) 
	 {
		 CUpdProduct* pProduct = m_lstProduct.at( i );
		 if  ( pProduct-&gt;getName() == qsName )
			 return pProduct;
	 }
	 return 0;
}
</xs:documentation>
			<xs:documentation source="getUpdateByUuid">header_fragment:
	CUpdate* getUpdateByUuid( const QString&amp; qsUuid ) const;
</xs:documentation>
			<xs:documentation source="getUpdateByUuid_impl">unit_fragment:
CUpdate* CUpdates::getUpdateByUuid( const QString&amp; qsUuid ) const
{
	 for ( int i = 0; i &lt; m_lstProduct.size(); ++i) 
	 {
		 CUpdate* pUpdate = m_lstProduct.at( i )-&gt;getUpdateByUuid(qsUuid);
		 if  ( pUpdate )
			 return pUpdate;
	 }
	 return 0;
}
</xs:documentation>
			<xs:documentation source="Init constructor">header_fragment:
    CUpdates(QString s) { InitLists(); fromString(s); }</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:sequence>
				<xs:element name="Product" minOccurs="0" maxOccurs="unbounded">
					<xs:annotation>
						<xs:documentation>class=CUpdProduct;</xs:documentation>
						<xs:documentation source="Version">header_fragment:
	// Get updating products versions
	const QList&lt;CUpdProductVersion* &gt;* getVersions() const
		{ return &amp;m_lstVersion; }
	// Add a updating product varsion to the list
	void addVersion( CUpdProductVersion* ); 
	// Get a product version
	CUpdProductVersion* getVersion( 
		unsigned int nMajor, unsigned int nMinor, 
		unsigned int nSubMinor, unsigned int nSubSubMinor ) const;
	// Delete a updating product version from the list
	void deleteVersion( CUpdProductVersion* ); 
</xs:documentation>
						<xs:documentation source="Version_impl">unit_fragment:
void CUpdProduct::addVersion( CUpdProductVersion* pVersion )
{
	m_lstVersion.append( pVersion );
}

void CUpdProduct::deleteVersion( CUpdProductVersion* pVersion )
{
	m_lstVersion.removeAll( pVersion );
	delete pVersion;
}

CUpdProductVersion* CUpdProduct::getVersion( 
	unsigned int nMajor, unsigned int nMinor, 
	unsigned int nSubMinor, unsigned int nSubSubMinor ) const
{
	 for ( int i = 0; i &lt; m_lstVersion.size(); ++i) 
	 {
		 CUpdProductVersion* pVersion = m_lstVersion.at( i );
		 if  ( pVersion-&gt;getMajor() == nMajor &amp;&amp;
				pVersion-&gt;getMinor() == nMinor &amp;&amp;
				pVersion-&gt;getSubMinor() == nSubMinor &amp;&amp;
				pVersion-&gt;getSubSubMinor() == nSubSubMinor )
			 return pVersion;
	 }
	 return 0;
}
</xs:documentation>
						<xs:documentation source="getUpdateByUuid">header_fragment:
	// Get an update by its UUID
	CUpdate* getUpdateByUuid( const QString&amp; qsUuid ) const;
</xs:documentation>
						<xs:documentation source="getUpdateByUuid_impl">unit_fragment:
CUpdate* CUpdProduct::getUpdateByUuid( const QString&amp; qsUuid ) const
{
	if ( !qsUuid.isEmpty() )
		for ( int i = 0; i &lt; m_lstVersion.size(); ++i) 
		{
			CUpdate* pUpdate = m_lstVersion.at( i )-&gt;getUpdateByUuid(qsUuid);
			if  ( pUpdate )
				return pUpdate;
		}
	 return 0;
}
</xs:documentation>
					</xs:annotation>
					<xs:complexType>
						<xs:sequence>
							<xs:element name="ProductName" type="xs:string">
								<xs:annotation>
									<xs:documentation>method=Name;</xs:documentation>
								</xs:annotation>
							</xs:element>
							<xs:element name="UpdateEnabled" type="xs:boolean" default="true"/>
							<xs:element name="Version" minOccurs="0" maxOccurs="unbounded">
								<xs:annotation>
									<xs:documentation>Updater config uses only one version for one update.</xs:documentation>
									<xs:documentation>class=CUpdProductVersion;</xs:documentation>
									<xs:documentation source="getUpdateByUuid">header_fragment:
	CUpdate* getUpdateByUuid( const QString&amp; qsUuid ) const;
</xs:documentation>
									<xs:documentation source="getUpdateByUuid_impl">unit_fragment:
CUpdate* CUpdProductVersion::getUpdateByUuid( const QString&amp; qsUuid ) const
{
	if ( !qsUuid.isEmpty() )
		for ( int i = 0; i &lt; m_lstUpdates.size(); ++i) 
		{
			CUpdate* pUpdate = m_lstUpdates.at( i );
			if  ( pUpdate-&gt;getUuid() == qsUuid )
			return pUpdate;
		}
	 return 0;
}
</xs:documentation>
									<xs:documentation source="Update">header_fragment:
	// Get update list
	const QList&lt;CUpdate*&gt;* getUpdates() const
		{ return &amp;m_lstUpdates; }
	// Add an update to the list
	void addUpdate( CUpdate* ); 

	// Delete an update from the list
	void deleteUpdate( CUpdate* ); 
</xs:documentation>
									<xs:documentation source="Update_impl">unit_fragment:
void CUpdProductVersion::addUpdate( CUpdate* pUpdate )
{
	m_lstUpdates.append( pUpdate );
}

void CUpdProductVersion::deleteUpdate( CUpdate* pUpdate )
{
	m_lstUpdates.removeAll( pUpdate );
	delete pUpdate;
}
</xs:documentation>
								</xs:annotation>
								<xs:complexType>
									<xs:sequence>
										<xs:element name="Major" type="xs:integer"/>
										<xs:element name="Minor" type="xs:integer"/>
										<xs:element name="SubMinor" type="xs:integer"/>
										<xs:element name="SubSubMinor" type="xs:integer"/>
										<xs:element name="StringRepresentation" type="xs:string"/>
										<xs:element name="Update" minOccurs="0" maxOccurs="unbounded">
											<xs:annotation>
												<xs:documentation>class=CUpdate;list=Updates</xs:documentation>
												<xs:documentation source="Ancestry">header_fragment:
    const QStringList* getAncestry();
    void addAncestor( const QString&amp; qsUuid );
    bool isAncestor( const QString&amp; qsUuid );
    void ClearAncestry() { m_lstAncestry[0]-&gt;m_lstAncestor.clear(); }</xs:documentation>
												<xs:documentation source="Ancestry_impl">unit_fragment:
const QStringList* CUpdate::getAncestry()
{
    return (QStringList* )&amp;m_lstAncestry[0]-&gt;m_lstAncestor;
}

void CUpdate::addAncestor( const QString&amp; qsUuid )
{
    m_lstAncestry[0]-&gt;m_lstAncestor += qsUuid;
}

bool CUpdate::isAncestor( const QString&amp; qsUuid )
{
    return m_lstAncestry[0]-&gt;m_lstAncestor.contains(qsUuid);
}
</xs:documentation>
												<xs:documentation source="post class info">post_class_info:
#if defined(_WIN_)
	#define VER_OS_TYPE_STR "win"
#elif defined(_LIN_)
	#define VER_OS_TYPE_STR "lin"
#endif
</xs:documentation>
											</xs:annotation>
											<xs:complexType>
												<xs:sequence>
													<xs:element name="Uuid" type="xs:string" minOccurs="0">
														<xs:annotation>
															<xs:documentation>method=Uuid;default=Uuid::createUuid().toString();attribute=uuid;</xs:documentation>
														</xs:annotation>
													</xs:element>
													<xs:element name="UpdateType" type="xs:integer" minOccurs="0">
														<xs:annotation>
															<xs:documentation>type=PVE::UpdateType;default=PVE::UpdateType_Cumulative;</xs:documentation>
														</xs:annotation>
													</xs:element>
													<xs:element name="UpdateName" type="xs:string" maxOccurs="unbounded">
														<xs:annotation>
															<xs:documentation>method=Name;</xs:documentation>
														</xs:annotation>
													</xs:element>
													<xs:element name="UpdateDescription" type="xs:string" maxOccurs="unbounded">
														<xs:annotation>
															<xs:documentation>method=Description;</xs:documentation>
														</xs:annotation>
													</xs:element>
													<xs:element name="FilePath" type="xs:string">
														<xs:annotation>
															<xs:documentation>Full path and name of downloaded file. If the file was installed this element has to be empty.</xs:documentation>
														</xs:annotation>
													</xs:element>
													<xs:element name="FileSize" type="xs:integer">
														<xs:annotation>
															<xs:documentation>If the update was installed then it is the size of all installed files, else it is the size of update file. </xs:documentation>
														</xs:annotation>
													</xs:element>
													<xs:element name="CheckSum" type="xs:string" minOccurs="0"/>
													<xs:element name="Status" type="xs:integer">
														<xs:annotation>
															<xs:documentation>Downloaded, Installed, PostponedDownload, DismissedDownload, PartlyDownloaded</xs:documentation>
															<xs:documentation>type=PVE::UpdateStatus;default=PVE::UpdateStatus_ReadyToUpdate;</xs:documentation>
														</xs:annotation>
													</xs:element>
													<xs:element name="DateTime" type="xs:string">
														<xs:annotation>
															<xs:documentation>It is a time stamp when a current status was set.</xs:documentation>
															<xs:documentation>type=QDateTime;</xs:documentation>
														</xs:annotation>
													</xs:element>
													<xs:element name="Chargeable" type="xs:boolean"/>
													<xs:element name="LocaleName" type="xs:string"/>
													<xs:element name="DistributorName" type="xs:string"/>
													<xs:element name="OsType" type="xs:string"/>
													<xs:element name="Ancestry">
														<xs:annotation>
															<xs:documentation>A UUIDs list of updates which can be updated by this update. It is not used in the updater config.</xs:documentation>
															<xs:documentation>single_fixed=on;</xs:documentation>
															<xs:documentation source="Friend class">header_fragment:
    friend class CUpdate;
</xs:documentation>
														</xs:annotation>
														<xs:complexType>
															<xs:sequence>
																<xs:element name="Ancestor" type="xs:string" minOccurs="0" maxOccurs="unbounded"/>
															</xs:sequence>
														</xs:complexType>
													</xs:element>
													<xs:element name="HotfixSN" type="xs:integer" default="0" minOccurs="0"/>
												</xs:sequence>
												<xs:attribute name="uuid" type="xs:string" use="required"/>
											</xs:complexType>
										</xs:element>
									</xs:sequence>
								</xs:complexType>
							</xs:element>
						</xs:sequence>
					</xs:complexType>
				</xs:element>
			</xs:sequence>
			<xs:attribute name="schemaVersion" type="xs:string" use="optional"/>
		</xs:complexType>
	</xs:element>
</xs:schema>
