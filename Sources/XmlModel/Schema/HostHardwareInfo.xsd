<?xml version="1.0" encoding="UTF-8"?>
<!-- edited with XML Spy v4.3 U (http://www.xmlspy.com) by sergeyt (para) -->
<!-- edited with XMLSpy v2007 sp2 (http://www.altova.com) by artemr (EMBRACE) -->
<!-- edited with XMLSPY v5 rel. 4 U (http://www.xmlspy.com) by rth77 (rth77) -->
<!--W3C Schema generated by XMLSPY v5 rel. 4 U (http://www.xmlspy.com)-->
<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema" elementFormDefault="qualified">
	<xs:element name="Active" type="xs:integer">
		<xs:annotation>
			<xs:documentation>method=IsActive;</xs:documentation>
		</xs:annotation>
	</xs:element>
	<xs:complexType name="CdROMType">
		<xs:annotation>
			<xs:documentation>class=CHwGenericDevice;extern=CHwGenericDevice.h;</xs:documentation>
			<xs:documentation source="getDeviceType">header_fragment:
    virtual PRL_DEVICE_TYPE getDeviceType() const { return PDE_OPTICAL_DISK; }
</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element ref="Name"/>
			<xs:element ref="Uuid"/>
		</xs:sequence>
	</xs:complexType>
	<xs:complexType name="CdROMsType">
		<xs:sequence>
			<xs:element name="CdROM" type="CdROMType" minOccurs="0" maxOccurs="unbounded"/>
		</xs:sequence>
	</xs:complexType>
	<xs:complexType name="DeviceInterfaceSettingsType">
		<xs:annotation>
			<xs:documentation>class=CHwDeviceInterfaceSettings;"</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="MaxIdeDevices" type="xs:integer" default="4"/>
			<xs:element name="MaxScsiDevices" type="xs:integer" default="16"/>
			<xs:element name="MaxSataDevices" type="xs:integer" default="6"/>
		</xs:sequence>
	</xs:complexType>
	<xs:complexType name="FloppyDiskType">
		<xs:annotation>
			<xs:documentation>class=CHwGenericDevice;extern=CHwGenericDevice.h;</xs:documentation>
			<xs:documentation source="getDeviceType">header_fragment:
    virtual PRL_DEVICE_TYPE getDeviceType() const { return PDE_FLOPPY_DISK; }

</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element ref="Name"/>
			<xs:element ref="Uuid"/>
		</xs:sequence>
	</xs:complexType>
	<xs:complexType name="FloppyDisksType">
		<xs:sequence>
			<xs:element name="FloppyDisk" type="FloppyDiskType" minOccurs="0" maxOccurs="unbounded"/>
		</xs:sequence>
	</xs:complexType>
	<xs:complexType name="GlobalNetworkType">
		<xs:annotation>
			<xs:documentation>class=CHwGlobalNetwork;</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="HostName" type="xs:string"/>
			<xs:element name="DefaultGateway" type="xs:string" minOccurs="0"/>
			<xs:element name="DefaultGatewayIPv6" type="xs:string" minOccurs="0"/>
			<xs:element name="DnsIPAddress" type="xs:string" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>method=DnsIPAddresses;</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="SearchDomain" type="xs:string" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>method=SearchDomains;</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
	</xs:complexType>
	<xs:complexType name="HardDiskType">
		<xs:annotation>
			<xs:documentation>class=CHwHardDisk;</xs:documentation>
			<xs:documentation source="Constructor">header_fragment:
	CHwHardDisk(QString dev_name, qint64 dev_size, unsigned int type = 0,
		QString dev_id = "", unsigned int index = 0);
</xs:documentation>
			<xs:documentation source="Constructor_impl">unit_fragment:
CHwHardDisk::CHwHardDisk(QString dev_name, qint64 dev_size, unsigned int type,
	 QString dev_id, unsigned int index)
{
	cleanupClassProperties();

	m_qsName = dev_name;
	m_qsUuid = dev_id;
	m_ctSize = dev_size;
	m_uiType = type;
	m_uiIndex = index;

}
</xs:documentation>
			<xs:documentation source="addPartition">header_fragment:
    void addPartition(CHwHddPartition* item) { m_lstPartitions += item; }
</xs:documentation>
			<xs:documentation source="getDeviceType">header_fragment:
    virtual PRL_DEVICE_TYPE getDeviceType() const { return PDE_HARD_DISK; }
</xs:documentation>
			<xs:documentation source="getAllPartitions">header_fragment:
    QList&lt;CHwHddPartition* &gt; getAllPartitions(const QList&lt;CHwHddPartition* &gt;&amp; list) const;</xs:documentation>
			<xs:documentation source="getAllPartitions_impl">unit_fragment:
QList&lt;CHwHddPartition* &gt; CHwHardDisk::getAllPartitions(const QList&lt;CHwHddPartition* &gt;&amp; list) const
{
    QList&lt;CHwHddPartition* &gt; all;
    foreach( CHwHddPartition* part, list )
    {
        all += part;
        all += getAllPartitions(part-&gt;m_lstPartitions);
    }
    return all;
}
</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="Name" type="xs:string">
				<xs:annotation>
					<xs:documentation>method=DeviceName;</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Size" type="xs:long">
				<xs:annotation>
					<xs:documentation>method=DeviceSize;type=qint64;</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element ref="Uuid"/>
			<xs:element ref="Type"/>
			<xs:element name="Index" type="xs:integer">
				<xs:annotation>
					<xs:documentation>method=DiskIndex;</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Partition" type="PartitionType" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>list=Partitions;</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Removable" type="xs:boolean" minOccurs="0"/>
			<xs:element name="External" type="xs:boolean" minOccurs="0"/>
		</xs:sequence>
	</xs:complexType>
	<xs:complexType name="HardDisksType">
		<xs:sequence>
			<xs:element name="BootCamp" type="xs:boolean" default="true" minOccurs="0"/>
			<xs:element name="HardDisk" type="HardDiskType" minOccurs="0" maxOccurs="unbounded"/>
		</xs:sequence>
	</xs:complexType>
	<xs:element name="HostRamSize" type="xs:integer"/>
	<xs:element name="InUse" type="xs:integer"/>
	<xs:element name="Index" type="xs:integer"/>
	<xs:element name="Logical" type="xs:integer">
		<xs:annotation>
			<xs:documentation>method=IsLogical;</xs:documentation>
		</xs:annotation>
	</xs:element>
	<xs:element name="MaxVmMemory" type="xs:integer"/>
	<xs:complexType name="MemorySettingsType">
		<xs:annotation>
			<xs:documentation>class=CHwMemorySettings;</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element ref="ReservedMemoryLimit"/>
			<xs:element ref="ReservedMemoryMax"/>
			<xs:element ref="MinVmMemory"/>
			<xs:element ref="MaxVmMemory"/>
			<xs:element ref="RecommendedMaxMemory"/>
			<xs:element ref="HostRamSize"/>
			<xs:element name="AdvancedMemoryInfo" minOccurs="0">
				<xs:complexType>
					<xs:sequence>
						<xs:element name="FreeMemSize" type="xs:integer" minOccurs="0"/>
						<xs:element name="WireMemSize" type="xs:integer" minOccurs="0"/>
						<xs:element name="InactiveMemSize" type="xs:integer" minOccurs="0"/>
						<xs:element name="ActiveMemSize" type="xs:integer" minOccurs="0"/>
						<xs:element name="VirtualMemSize" type="xs:integer" minOccurs="0"/>
						<xs:element name="ResidentMemSize" type="xs:integer" minOccurs="0"/>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
		</xs:sequence>
	</xs:complexType>
	<xs:element name="MinVmMemory" type="xs:integer"/>
	<xs:complexType name="MixerDeviceType">
		<xs:annotation>
			<xs:documentation>class=CHwGenericDevice;extern=CHwGenericDevice.h;</xs:documentation>
			<xs:documentation source="getDeviceType">header_fragment:
    virtual PRL_DEVICE_TYPE getDeviceType() const { return PDE_MIXER_DEVICE; }
</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element ref="Name"/>
			<xs:element ref="Uuid"/>
		</xs:sequence>
	</xs:complexType>
	<xs:complexType name="MixerDevicesType">
		<xs:sequence>
			<xs:element name="MixerDevice" type="MixerDeviceType" minOccurs="0" maxOccurs="unbounded"/>
		</xs:sequence>
	</xs:complexType>
	<xs:element name="Name">
		<xs:simpleType>
			<xs:restriction base="xs:string">
				<xs:enumeration value="FLOPPY"/>
				<xs:enumeration value="HD_NAME"/>
				<xs:enumeration value="NETWORK"/>
				<xs:enumeration value="OPTICAL"/>
				<xs:enumeration value="PARALLEL"/>
				<xs:enumeration value="PART_NAME"/>
				<xs:enumeration value="PRINTER"/>
				<xs:enumeration value="SERIAL"/>
				<xs:enumeration value="SOUND_MIX"/>
				<xs:enumeration value="SOUND_OUT"/>
				<xs:enumeration value="USB_DEVICE"/>
			</xs:restriction>
		</xs:simpleType>
	</xs:element>
	<xs:complexType name="NetAddressType">
		<xs:annotation>
			<xs:documentation>class=CHwNetAddress;</xs:documentation>
		</xs:annotation>
	</xs:complexType>
	<xs:complexType name="NetworkAdapterType">
		<xs:annotation>
			<xs:documentation>class=CHwNetAdapter;base_class=CHwGenericDevice;</xs:documentation>
			<xs:documentation source="getDeviceType">header_fragment:
    virtual PRL_DEVICE_TYPE getDeviceType() const { return PDE_GENERIC_NETWORK_ADAPTER; }
</xs:documentation>
			<xs:documentation source="Constructor">header_fragment:
	CHwNetAdapter(
		PRL_DEVICE_TYPE dev_type,
		const QString&amp; dev_name,
		const QString&amp; dev_sys_name,
		int	sysIndex,
		const QString&amp; macAddress,
		unsigned short vlanTag,
		bool	flgEnabled,
		QString uuid = "");
</xs:documentation>
			<xs:documentation source="Constructor_impl">unit_fragment:
CHwNetAdapter::CHwNetAdapter(PRL_DEVICE_TYPE dev_type, const QString&amp; dev_name, const QString&amp; dev_sys_name,  int sysIndex, const QString&amp; macAddress, unsigned short vlanTag, bool flgEnabled, QString uuid)
: CHwGenericDevice( dev_type, dev_name, dev_sys_name/*, parent */)
{
    Q_UNUSED(uuid);

     InitLists();


    setDeviceName(dev_name);
    setDeviceId(dev_sys_name);
    setSysIndex( sysIndex );
	setMacAddress( macAddress);
    setNetAdapterType( PHI_REAL_NET_ADAPTER );
    setEnabled( flgEnabled );
    setConfigureWithDhcp(false);
    setConfigureWithDhcpIPv6(false);
	setVLANTag(vlanTag);
}
</xs:documentation>
			<xs:documentation source="getEnabled">header_fragment:
	bool	getEnabled( ) const { return isEnabled(); }
</xs:documentation>
			<xs:documentation source="post read: drop DHCP flag">post_read_fragment:
    if ( isConfigureWithDhcp() )
        setConfigureWithDhcp( getNetAddresses().isEmpty() );</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="Name" type="xs:string">
				<xs:annotation>
					<xs:documentation>method=DeviceName;</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element ref="Uuid"/>
			<xs:element name="index" type="xs:int" default="-1">
				<xs:annotation>
					<xs:documentation>method=SysIndex;</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Type" type="xs:integer" default="PHI_VIRTUAL_NET_ADAPTER">
				<xs:annotation>
					<xs:documentation>method=NetAdapterType;type=PRL_HW_INFO_NET_ADAPTER_TYPE</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Enabled" type="xs:boolean"/>
			<xs:element name="MacAddress" type="xs:string" minOccurs="0"/>
			<xs:element name="NetAddress" type="xs:string" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>method=NetAddresses; Format "1.2.3.4/255.255.0.0"</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="ConfigureWithDhcp" type="xs:boolean" minOccurs="0"/>
			<xs:element name="DefaultGateway" type="xs:string" minOccurs="0"/>
			<xs:element name="ConfigureWithDhcpIPv6" type="xs:boolean" minOccurs="0"/>
			<xs:element name="DefaultGatewayIPv6" type="xs:string" minOccurs="0"/>
			<xs:element name="DnsIPAddress" type="xs:string" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>method=DnsIPAddresses; Need for Windows OS, per adapter option.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="SearchDomain" type="xs:string" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>method=SearchDomains; Need for Windows OS, per adapter option.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="VLANTag" type="xs:unsignedShort" default="PRL_INVALID_VLAN_TAG" minOccurs="0">
				<xs:annotation>
					<xs:documentation>Net interface is idenitified with pair MAC+VLAN_TAG. Several cards in system may have the same MAC if they are VLANs</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
	</xs:complexType>
	<xs:complexType name="NetworkAdaptersType">
		<xs:sequence>
			<xs:element name="NetworkAdapter" type="NetworkAdapterType" minOccurs="0" maxOccurs="unbounded"/>
		</xs:sequence>
	</xs:complexType>
	<xs:complexType name="NetworkSettingsType">
		<xs:annotation>
			<xs:documentation>class=CHwNetworkSettings</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="MaxVmNetAdapters" type="xs:integer"/>
			<xs:element name="MaxHostNetAdapters" type="xs:integer" default="16" minOccurs="0"/>
			<xs:element name="GlobalNetwork" type="GlobalNetworkType">
				<xs:annotation>
					<xs:documentation>single_fixed=on;</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
	</xs:complexType>
	<xs:complexType name="OutputDeviceType">
		<xs:annotation>
			<xs:documentation>class=CHwGenericDevice;extern=CHwGenericDevice.h;</xs:documentation>
			<xs:documentation source="getDeviceType">header_fragment:
virtual PRL_DEVICE_TYPE getDeviceType() const { return PDE_SOUND_DEVICE; }
</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element ref="Name"/>
			<xs:element ref="Uuid"/>
		</xs:sequence>
	</xs:complexType>
	<xs:complexType name="OutputDevicesType">
		<xs:sequence>
			<xs:element name="OutputDevice" type="OutputDeviceType" minOccurs="0" maxOccurs="unbounded"/>
		</xs:sequence>
	</xs:complexType>
	<xs:complexType name="ParallelPortType">
		<xs:annotation>
			<xs:documentation>class=CHwGenericDevice;extern=CHwGenericDevice.h;</xs:documentation>
			<xs:documentation source="getDeviceType">header_fragment:
    virtual PRL_DEVICE_TYPE getDeviceType() const { return PDE_PARALLEL_PORT; }
</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element ref="Name"/>
			<xs:element ref="Uuid"/>
		</xs:sequence>
	</xs:complexType>
	<xs:complexType name="ParallelPortsType">
		<xs:sequence>
			<xs:element name="ParallelPort" type="ParallelPortType" minOccurs="0" maxOccurs="unbounded"/>
		</xs:sequence>
	</xs:complexType>
	<xs:element name="ParallelsHostInfo">
		<xs:annotation>
			<xs:documentation>class=CHostHardwareInfoBase;</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:sequence>
				<xs:element ref="SoundDefaultEnabled"/>
				<xs:element ref="UsbSupported"/>
				<xs:element name="PSRasterizer">
					<xs:annotation>
						<xs:documentation>class=CPSRasterizer;single_fixed=on;</xs:documentation>
					</xs:annotation>
					<xs:complexType>
						<xs:sequence>
							<xs:element name="Description" type="xs:string" minOccurs="0"/>
							<xs:element name="Executable" type="xs:string" minOccurs="0"/>
						</xs:sequence>
					</xs:complexType>
				</xs:element>
				<xs:element name="VtdSupported" type="xs:boolean" minOccurs="0"/>
				<xs:element name="MemorySettings" type="MemorySettingsType">
					<xs:annotation>
						<xs:documentation>single_fixed=on;</xs:documentation>
					</xs:annotation>
				</xs:element>
				<xs:element name="HostNotebookFlag" type="xs:boolean" minOccurs="0"/>
				<xs:element name="NetworkSettings" type="NetworkSettingsType">
					<xs:annotation>
						<xs:documentation>single_fixed=on;</xs:documentation>
					</xs:annotation>
				</xs:element>
				<xs:element name="DeviceInterfaceSettings" type="DeviceInterfaceSettingsType">
					<xs:annotation>
						<xs:documentation>single_fixed=on;</xs:documentation>
					</xs:annotation>
				</xs:element>
				<xs:element name="FloppyDisks" type="FloppyDisksType">
					<xs:annotation>
						<xs:documentation>list=FloppyDisksBase;single_fixed=on;</xs:documentation>
					</xs:annotation>
				</xs:element>
				<xs:element name="CdROMs" type="CdROMsType">
					<xs:annotation>
						<xs:documentation>single_fixed=on;</xs:documentation>
					</xs:annotation>
				</xs:element>
				<xs:element name="HardDisks" type="HardDisksType">
					<xs:annotation>
						<xs:documentation>list=HardDisksBase;single_fixed=on;</xs:documentation>
					</xs:annotation>
				</xs:element>
				<xs:element name="SerialPorts" type="SerialPortsType">
					<xs:annotation>
						<xs:documentation>list=SerialPortsBase;single_fixed=on;</xs:documentation>
					</xs:annotation>
				</xs:element>
				<xs:element name="ParallelPorts" type="ParallelPortsType">
					<xs:annotation>
						<xs:documentation>list=ParallelPortsBase;single_fixed=on;</xs:documentation>
					</xs:annotation>
				</xs:element>
				<xs:element name="NetworkAdapters" type="NetworkAdaptersType">
					<xs:annotation>
						<xs:documentation>list=NetworkAdaptersBase;single_fixed=on;</xs:documentation>
					</xs:annotation>
				</xs:element>
				<xs:element name="SoundDevices" type="SoundDevicesType">
					<xs:annotation>
						<xs:documentation>single_fixed=on;</xs:documentation>
					</xs:annotation>
				</xs:element>
				<xs:element name="UsbDevices" type="UsbDevicesType">
					<xs:annotation>
						<xs:documentation>list=UsbDevicesBase;single_fixed=on;</xs:documentation>
					</xs:annotation>
				</xs:element>
				<xs:element name="Printers" type="PrintersType">
					<xs:annotation>
						<xs:documentation>list=PrintersBase;single_fixed=on;</xs:documentation>
					</xs:annotation>
				</xs:element>
				<xs:element name="Cpu">
					<xs:annotation>
						<xs:documentation>class=CHwCpu;single_fixed=on;</xs:documentation>
						<xs:documentation source="getVtdEnable">header_format:
    bool getVtdEnable() const { return isVtdEnable(); }</xs:documentation>
					</xs:annotation>
					<xs:complexType>
						<xs:sequence>
							<xs:element name="Number" type="xs:integer" default="XML_DEFAULT_HW_CPU_NUMBER"/>
							<xs:element name="Model" type="xs:string"/>
							<xs:element name="Mode" type="xs:integer" default="PCM_CPU_MODE_32">
								<xs:annotation>
									<xs:documentation>type=PRL_CPU_MODE;</xs:documentation>
								</xs:annotation>
							</xs:element>
							<xs:element name="Speed" type="xs:integer"/>
							<xs:element name="VtxEnabled" type="xs:boolean" minOccurs="0">
								<xs:annotation>
									<xs:documentation>method=VtdEnable;</xs:documentation>
								</xs:annotation>
							</xs:element>
							<xs:element name="VtxMode" type="xs:integer" default="PCM_CPU_NONE_HV" minOccurs="0">
								<xs:annotation>
									<xs:documentation>type=PRL_CPU_HVT;</xs:documentation>
								</xs:annotation>
							</xs:element>
							<xs:element name="HvtNptAvail" type="xs:boolean" minOccurs="0"/>
							<xs:element name="HvtUnrestrictedAvail" type="xs:boolean" minOccurs="0"/>
							<xs:element name="FEATURES" type="xs:integer" minOccurs="0"/>
							<xs:element name="EXT_FEATURES" type="xs:integer" minOccurs="0"/>
							<xs:element name="EXT_80000001_ECX" type="xs:integer" minOccurs="0"/>
							<xs:element name="EXT_80000001_EDX" type="xs:integer" minOccurs="0"/>
							<xs:element name="EXT_80000007_EDX" type="xs:integer" minOccurs="0"/>
							<xs:element name="EXT_80000008_EAX" type="xs:integer" minOccurs="0"/>
							<xs:element name="EXT_00000007_EBX" type="xs:integer" minOccurs="0"/>
							<xs:element name="EXT_0000000D_EAX" type="xs:integer" minOccurs="0"/>
							<xs:element name="FEATURES_MASKING_CAP" type="xs:integer" minOccurs="0"/>
							<xs:element name="EXT_FEATURES_MASKING_CAP" type="xs:integer" minOccurs="0"/>
							<xs:element name="EXT_80000001_ECX_MASKING_CAP" type="xs:integer" minOccurs="0"/>
							<xs:element name="EXT_80000001_EDX_MASKING_CAP" type="xs:integer" minOccurs="0"/>
							<xs:element name="EXT_80000007_EDX_MASKING_CAP" type="xs:integer" minOccurs="0"/>
							<xs:element name="EXT_80000008_EAX_MASKING_CAP" type="xs:integer" minOccurs="0"/>
							<xs:element name="EXT_00000007_EBX_MASKING_CAP" type="xs:integer" minOccurs="0"/>
							<xs:element name="EXT_0000000D_EAX_MASKING_CAP" type="xs:integer" minOccurs="0"/>
						</xs:sequence>
					</xs:complexType>
				</xs:element>
				<xs:element name="OsVersion">
					<xs:annotation>
						<xs:documentation>class=CHwOsVersion;single_fixed=on;</xs:documentation>
					</xs:annotation>
					<xs:complexType>
						<xs:sequence>
							<xs:element name="Type" type="xs:integer" default="PHO_MAC">
								<xs:annotation>
									<xs:documentation>method=OsType;type=PRL_HOST_OS_TYPE;</xs:documentation>
								</xs:annotation>
							</xs:element>
							<xs:element name="Major" type="xs:integer"/>
							<xs:element name="Minor" type="xs:integer"/>
							<xs:element name="SubMinor" type="xs:integer"/>
							<xs:element name="StringPresentation" type="xs:string"/>
							<xs:element name="OsArchitecture" type="xs:string" minOccurs="0"/>
							<xs:element name="KernelArchitecture" type="xs:string" minOccurs="0"/>
							<xs:element name="VzRunning" type="xs:boolean" default="false" minOccurs="0"/>
						</xs:sequence>
					</xs:complexType>
				</xs:element>
				<xs:element name="GenericPciDevices">
					<xs:annotation>
						<xs:documentation>list=GenericPciDevicesBase;single_fixed=on;</xs:documentation>
					</xs:annotation>
					<xs:complexType>
						<xs:sequence>
							<xs:element name="GenericPciDevice" minOccurs="0" maxOccurs="unbounded">
								<xs:annotation>
									<xs:documentation>class=CHwGenericPciDevice;base_class=CHwGenericDevice;</xs:documentation>
									<xs:documentation source="getDeviceType">header_fragment:
    virtual PRL_DEVICE_TYPE getDeviceType() const { return PDE_GENERIC_PCI_DEVICE; }</xs:documentation>
								</xs:annotation>
								<xs:complexType>
									<xs:sequence>
										<xs:element name="Name" type="xs:string">
											<xs:annotation>
												<xs:documentation>method=DeviceName;method_base_class=CHwGenericDevice;</xs:documentation>
											</xs:annotation>
										</xs:element>
										<xs:element name="Uuid" type="xs:string">
											<xs:annotation>
												<xs:documentation>method=DeviceId;method_base_class=CHwGenericDevice;default=Uuid::createUuid().toString();</xs:documentation>
											</xs:annotation>
										</xs:element>
										<xs:element name="Type" type="xs:integer" default="PGD_PCI_NETWORK" minOccurs="0">
											<xs:annotation>
												<xs:documentation>type=PRL_GENERIC_PCI_DEVICE_CLASS;</xs:documentation>
											</xs:annotation>
										</xs:element>
										<xs:element name="DeviceState" type="xs:integer" minOccurs="0">
											<xs:annotation>
												<xs:documentation>method_base_class=CHwGenericDevice;type=PRL_GENERIC_DEVICE_STATE;default=PGS_CONNECTED_TO_HOST;</xs:documentation>
											</xs:annotation>
										</xs:element>
										<xs:element name="Supported" type="xs:boolean" default="true" minOccurs="0"/>
										<xs:element name="Primary" type="xs:boolean" default="false" minOccurs="0"/>
									</xs:sequence>
								</xs:complexType>
							</xs:element>
						</xs:sequence>
					</xs:complexType>
				</xs:element>
				<xs:element name="GenericScsiDevices">
					<xs:annotation>
						<xs:documentation>list=GenericScsiDevicesBase;single_fixed=on;</xs:documentation>
					</xs:annotation>
					<xs:complexType>
						<xs:sequence>
							<xs:element name="GenericScsiDevice" minOccurs="0" maxOccurs="unbounded">
								<xs:annotation>
									<xs:documentation>class=CHwGenericDevice;extern=CHwGenericDevice.h;</xs:documentation>
									<xs:documentation source="getDeviceType">header_fragment:
    virtual PRL_DEVICE_TYPE getDeviceType() const { return PDE_GENERIC_SCSI_DEVICE; }
</xs:documentation>
								</xs:annotation>
								<xs:complexType>
									<xs:sequence>
										<xs:element ref="Name"/>
										<xs:element ref="Uuid"/>
									</xs:sequence>
								</xs:complexType>
							</xs:element>
						</xs:sequence>
					</xs:complexType>
				</xs:element>
				<xs:element name="VtdInitializationCode" type="xs:integer" default="PVSC_NOT_PRESENT" minOccurs="0"/>
			</xs:sequence>
			<xs:attribute name="schemaVersion" type="xs:decimal" use="required"/>
		</xs:complexType>
	</xs:element>
	<xs:complexType name="PartitionType">
		<xs:annotation>
			<xs:documentation>class=CHwHddPartition;</xs:documentation>
			<xs:documentation source="Constructor">header_fragment:
	CHwHddPartition(QString name, qint64 size, unsigned int type = 0,
		unsigned int index = 0, unsigned int logical = 0, unsigned int active = 0, unsigned int in_use = 0 )
{
    InitLists();
	m_qsName = name;
		m_ctSize = size;
		m_uiIndex = index;
		m_uiInUse = in_use;
		m_uiType = type;
		m_uiLogical = logical;
		m_uiActive = active;
	};
</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="Name" type="xs:string"/>
			<xs:element name="SystemName" type="xs:string" minOccurs="0"/>
			<xs:element ref="Size"/>
			<xs:element name="FreeSize" type="xs:integer" default="(qint64 )-1" minOccurs="0">
				<xs:annotation>
					<xs:documentation>type=qint64;</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element ref="Index"/>
			<xs:element ref="InUse"/>
			<xs:element ref="Type"/>
			<xs:element ref="Logical"/>
			<xs:element ref="Active"/>
			<xs:element name="Partition" type="PartitionType" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>list=Partitions;</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
	</xs:complexType>
	<xs:complexType name="PrinterType">
		<xs:annotation>
			<xs:documentation>class=CHwPrinter;base_class=CHwGenericDevice;</xs:documentation>
			<xs:documentation source="getDeviceType">header_fragment:
    virtual PRL_DEVICE_TYPE getDeviceType() const { return PDE_PRINTER; }
</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="Name" type="xs:string" minOccurs="0">
				<xs:annotation>
					<xs:documentation>method=DeviceName;method_base_class=CHwGenericDevice;</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Uuid" type="xs:string" minOccurs="0">
				<xs:annotation>
					<xs:documentation>method=DeviceId;method_base_class=CHwGenericDevice;</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Default" type="xs:boolean" minOccurs="0"/>
		</xs:sequence>
	</xs:complexType>
	<xs:complexType name="PrintersType">
		<xs:sequence>
			<xs:element name="Printer" type="PrinterType" minOccurs="0" maxOccurs="unbounded"/>
		</xs:sequence>
	</xs:complexType>
	<xs:element name="RecommendedMaxMemory" type="xs:integer">
		<xs:annotation>
			<xs:documentation>method=RecommendedMaxVmMemory;</xs:documentation>
		</xs:annotation>
	</xs:element>
	<xs:element name="ReservedMemoryLimit" type="xs:integer"/>
	<xs:element name="ReservedMemoryMax" type="xs:integer">
		<xs:annotation>
			<xs:documentation>method=MaxReservedMemoryLimit;</xs:documentation>
		</xs:annotation>
	</xs:element>
	<xs:complexType name="SerialPortType">
		<xs:annotation>
			<xs:documentation>class=CHwGenericDevice;extern=CHwGenericDevice.h;</xs:documentation>
			<xs:documentation source="getDeviceType">header_fragment:
    virtual PRL_DEVICE_TYPE getDeviceType() const { return PDE_SERIAL_PORT; }
</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element ref="Name"/>
			<xs:element ref="Uuid"/>
		</xs:sequence>
	</xs:complexType>
	<xs:complexType name="SerialPortsType">
		<xs:sequence>
			<xs:element name="SerialPort" type="SerialPortType" minOccurs="0" maxOccurs="unbounded"/>
		</xs:sequence>
	</xs:complexType>
	<xs:element name="Size" type="xs:integer">
		<xs:annotation>
			<xs:documentation>type=qint64;</xs:documentation>
		</xs:annotation>
	</xs:element>
	<xs:element name="SoundDefaultEnabled" type="xs:integer"/>
	<xs:complexType name="SoundDevicesType">
		<xs:annotation>
			<xs:documentation/>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="OutputDevices" type="OutputDevicesType">
				<xs:annotation>
					<xs:documentation>single_fixed=on;</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="MixerDevices" type="MixerDevicesType">
				<xs:annotation>
					<xs:documentation>single_fixed=on;</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
	</xs:complexType>
	<xs:element name="Type" type="xs:integer"/>
	<xs:complexType name="UsbDeviceType">
		<xs:annotation>
			<xs:documentation>class=CHwUsbDevice;base_class=CHwGenericDevice;</xs:documentation>
			<xs:documentation source="getDeviceType">header_fragment:
    virtual PRL_DEVICE_TYPE getDeviceType() const { return PDE_USB_DEVICE; }
</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="Name" type="xs:string" minOccurs="0">
				<xs:annotation>
					<xs:documentation>method=DeviceName;method_base_class=CHwGenericDevice;</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Uuid" type="xs:string" minOccurs="0">
				<xs:annotation>
					<xs:documentation>method=DeviceId;method_base_class=CHwGenericDevice;</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="VmUuid" type="xs:string" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>method=VmUuids;method_base_class=CHwGenericDevice;</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="DeviceState" type="xs:integer" default="PGS_CONNECTED_TO_HOST" minOccurs="0">
				<xs:annotation>
					<xs:documentation>method=DeviceState;method_base_class=CHwGenericDevice;type=PRL_GENERIC_DEVICE_STATE;default=PGS_CONNECTED_TO_HOST;</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="UsbType" type="xs:integer" minOccurs="0">
				<xs:annotation>
					<xs:documentation>type=PRL_USB_DEVICE_TYPE;default=PUDT_OTHER;</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
	</xs:complexType>
	<xs:complexType name="UsbDevicesType">
		<xs:sequence>
			<xs:element name="UsbDevice" type="UsbDeviceType" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation/>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
	</xs:complexType>
	<xs:element name="UsbSupported" type="xs:integer"/>
	<xs:element name="Uuid">
		<xs:annotation>
			<xs:documentation>method=DeviceId;default=Uuid::createUuid().toString();</xs:documentation>
		</xs:annotation>
		<xs:simpleType>
			<xs:restriction base="xs:string">
				<xs:enumeration value="FLOP_UUID"/>
				<xs:enumeration value="HD_UUID"/>
				<xs:enumeration value="NET_UUID"/>
				<xs:enumeration value="OPT_UUID"/>
				<xs:enumeration value="PRINTER_UUID"/>
				<xs:enumeration value="PRL_UUID"/>
				<xs:enumeration value="SER_UUID"/>
				<xs:enumeration value="SND_MIX_UUID"/>
				<xs:enumeration value="SND_OUT_UUID"/>
				<xs:enumeration value="USB_DEV_UUID"/>
			</xs:restriction>
		</xs:simpleType>
	</xs:element>
	<xs:element name="VirtualNicGuid" type="xs:string"/>
</xs:schema>
